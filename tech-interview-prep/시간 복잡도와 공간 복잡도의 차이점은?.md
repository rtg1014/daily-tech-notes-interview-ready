## 개요

- 하나의 문제를 해결하는 여러 알고리즘이 존재할 수 있습니다. 그리고, 개발자는 성능을 평가하여 하나를 결정해야 합니다. 이때, 코드가 실행될 때 걸리는 정확한 시간을 측정하는 방법으로 속도를 비교할 수 있습니다. 하지만, 실행 시간은 기계에 의존적이며 대안으로 나온 알고리즘들이 모두 짧은 시간 내로 수행되어 비교가 어려울 수 있습니다.

<br>

- 이러한 경우, 직접 속도를 측정하는 것이 아닌 컴퓨터가 처리해야 하는 연산의 수를 세는 것이 나은 방법일 수 있습니다.
- 이러한 아이디어를 기반으로 특정 입력을 기준으로 개략적인 연산의 수를 계산한 것이 `시간 복잡도(Time Complexity)` 입니다.
- 반면, `공간 복잡도(Space Complexity)` 는 특정 입력을 기준으로 알고리즘이 얼마나 많은 공간을 차지하는지를 다룹니다.


<br>


- 정리하자면, 시간 복잡도와 공간 복잡도는 모두 알고리즘 평가의 척도로 사용될 수 있습니다.
- 시간 복잡도는 개략적인 연산의 수를 기준으로 알고리즘 속도를 평가하는 척도로 사용되는 반면, 공간 복잡도는 알고리즘의 메모리 사용량을 평가하는 척도로 사용되는 것이 차이점입니다.

<br>


## 빅오 표기법은 무엇인가요? 
- 빅오 표기법은 복잡도를 표현하는 표기법 중 하나로 불필요한 상세를 무시하고 필수적인 부분에 집중하는 점근적 표기법을 따릅니다.
- 빅오 표기법은 O(n) 형식으로 어떤 함수의 입력 값에 따라 알고리즘의 실행 시간 및 공간 사용량이 어떻게 변하는지를 설명합니다.
- 빅오 표기법의 예시는 다음과 같습니다.

  <br>


```java

// n이 입력되면 n번 루프가 반복되므로, O(n)으로 표기합니다.
for (int i = 0; i < n; i++) { ... }

// 아래 루프는 O(n)으로 표기합니다. n이 무한에 가까울 수록 k가 의미가 없기 때문입니다. (상수항과 계수 무시)
int k = 5;
for (int i = 0; i < n * k; i++) { ... }

// 입력값인 n과 m이 독립적이라면 빅오는 더할 수 있습니다. O(n + m)으로 표기합니다.
for (int i = 0; i < n; i++) { ... }
for (int i = 0; i < m; i++) { ... }

// 빅오는 곱해질 수 있습니다. O(n^2)으로 표기합니다.
for (int i = 0; i < n; i++) {
  for (int j = 0; j < n * 5; j++) {}
}

// 가장 큰 항 외에는 무시할 수 있습니다. O(n^2)로 표기합니다.
for (int i = 0; i < n; i++) {}

for (int i = 0; i < n; i++) {
  for (int j = 0; j < n; j++) {}
}

```

---

<br> <br> <br>


> ## 추가학습자료

[10분 테코톡] 🙋‍♂️제이의 시간복잡도
출처 : https://www.youtube.com/watch?v=IEH3YA2Nn4Q


---

# ✅ 발표 주제: 알고리즘 & 시간 복잡도

---

## 🎯 발표 목표  
- 알고리즘이란 무엇인지 감 잡기  
- 시간 복잡도의 의미와 왜 중요한지 이해  
- 일상 속 예시와 함께, 알고리즘을 눈앞의 문제처럼 체감하기  
- 현실적/비현실적 알고리즘을 구분하고, 보안과 연결되는 깊은 개념까지 가볍게 엿보기

---

## 1. 🤔 알고리즘이란?

### ✅ 정의  
문제를 해결하기 위한 **절차적 방법**. 즉, “문제를 어떻게 풀 것인가”에 대한 계획.

### 💬 일상 비유
- 아침에 회사 가는 법도 하나의 알고리즘  
  > 지하철을 탈까, 버스를 탈까, 걸을까?  
  > → "문제": 출근하기  
  > → "알고리즘": 가장 빠르고 편한 경로 찾기

---

## 2. 💘 재미있는 알고리즘 예제: "배우자 찾기 알고리즘"

> 💡 이건 실제 수학적 증명까지 존재하는 알고리즘입니다.  
> "시크릿 토너먼트 문제" 또는 "비서 문제"라고 불립니다.

### 🎬 시나리오
- 결혼을 위한 3번의 소개팅 기회가 주어진다.
- 단, 한 명만 선택할 수 있다. 지나간 사람은 다시 선택할 수 없다.
- 목표: **가장 좋은 사람을 고르는 것!**

---

### 🧪 전략 ①: 0명 살펴보기  
- 바로 첫 번째 만난 사람을 고른다 → 확률은 단순히 1/3 (33%)

### 🧪 전략 ②: 1명 살펴보기  
- 첫 번째 사람은 “무조건 넘긴다”  
- 두 번째부터, 첫 번째보다 **더 괜찮은 사람**이 나오면 바로 선택  
- 확률: 약 50%!

> 🎯 핵심 전략  
> 전체 사람 수 n일 때, 앞의 n × 37% 정도는 **무조건 넘기고**,  
> 그 이후부터는 앞에서 본 사람보다 더 나은 사람이 나오면 바로 선택!

### 💬 비유
> 마트에서 할인된 상품 중 최고를 찾고 싶다면?  
> 100개 중 앞의 37개는 쓱 스캔만 하고,  
> 38번째부터는 그중 최고보다 좋은 상품이 보이면 바로 장바구니로!

---

## 3. ⏱️ 시간 복잡도란?

### ✅ 정의  
**입력 크기(n)**에 따라 **알고리즘 수행 시간**이 어떻게 늘어나는지를 수학적으로 표현한 것.

> 우리가 알고리즘을 평가할 때는, 보통 **최악의 경우 (Worst Case)** 를 기준으로 한다.  
> 왜냐하면 평균은 정의하기 어렵고, 최선의 경우는 보장할 수 없기 때문.

---

### 🧩 대표적인 시간 복잡도 예시

| 복잡도 | 의미 | 예시 |
|--------|------|------|
| O(1)   | 입력 크기에 무관 | 딱 한 번 연산 (예: 변수 값 출력) |
| O(log n) | 로그 단위로 증가 | 이진 탐색 |
| O(n)   | 입력 만큼 반복 | 선형 탐색 |
| O(n log n) | 정렬 | Merge Sort, Quick Sort (평균) |
| O(n²)  | 중첩 반복 | 버블 정렬, 선택 정렬 |
| O(2ⁿ), O(n!) | 매우 비효율적 | 외판원 문제, 순열 생성 등 |

---

### 💬 일상 비유
> 💡 O(n): 친구 생일 선물 사러 매장을 1개씩 다 돌아다니며 찾기  
> 💡 O(log n): 원하는 책을 사전에서 찾을 때 가운데부터 펼쳐서 찾기  
> 💡 O(n²): 커플 100쌍이 각자 서로 편지를 주고받을 때 → 편지 수는 거의 10,000개

---

## 4. 🧱 현실적인 알고리즘 vs 비현실적인 알고리즘

### 🟢 현실적인 알고리즘  
- 보통 O(n log n) 이하  
- 1시간 안에 해결 가능한 알고리즘  
- 정렬, 탐색, 해시 등

> ex) n=10⁶일 때 O(n log n) → 약 2천만 번 연산 → 컴퓨터로 가능!

---

### 🔴 비현실적인 알고리즘  
- O(2ⁿ), O(n!) 등  
- 입력이 조금만 커져도 시간이 **기하급수적으로 늘어남**

> 🎓 외판원 문제, 여행 경로 최적화 등 → 경우의 수가 너무 많음

---

## 5. 🔐 보안과 알고리즘: 암호와 시간 복잡도

### 🔸 RSA 알고리즘 (공개키 암호 시스템)
- 소인수분해가 매우 어렵다는 성질을 이용한 보안 체계
- 두 소수 p, q의 곱인 n = pq는 공개돼도, p와 q를 찾는 건 어렵다 → **비대칭키 보안**

---

### 💣 만약 P = NP라면?

> P: "빠르게 풀 수 있는 문제"  
> NP: "답이 맞는지 빠르게 검증할 수 있는 문제"

- P = NP라면 → **보안 다 뚫림**
- 세상의 모든 **공개키 암호 시스템**이 무력화됨
- “전 인류의 사이버 안전이 위협받는다”  
  → 밀레니엄 문제 7개 중 하나로, **1억 원 넘는 상금**이 걸려 있음

---

## 🎬 마무리 요약

| 항목 | 설명 | 비유 |
|------|------|------|
| 알고리즘 | 문제 해결 절차 | 회사 가는 루트 선택 |
| 시간 복잡도 | 실행 시간 증가율 | 마트 상품 고르기 vs 할인구역 전체 훑기 |
| 비서 문제 | 최적 타이밍의 선택 전략 | 앞 37% 넘기고 그 다음부터 비교 |
| 현실/비현실 | n log n vs 팩토리얼 | 수능 문제 vs 외판원 여행 코스 |
| 보안 연계 | P ≠ NP 덕에 보안 유지 | 자물쇠는 잠그기 쉽지만 열기 어렵다 |

---

## 📚 참고 키워드 (더 알아보면 좋은 주제)
- NP-완전 문제, NP-하드 문제
- 공약수, 소인수분해, RSA
- 최적화 알고리즘 (그리디, DP, 백트래킹 등)
- Big-O, Big-Theta, Big-Omega

---
