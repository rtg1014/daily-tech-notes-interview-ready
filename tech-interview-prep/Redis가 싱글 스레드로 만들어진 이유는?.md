## Redis가 단일 스레드(single-threaded)로 설계된 이유는 주로 성능 최적화, 복잡성 감소, 그리고 데이터 일관성을 유지에 있습니다.

- 단일 스레드 모델은 멀티스레드 모델에 비해 설계와 구현이 상대적으로 간단합니다.
- 멀티스레드 환경에서는 동시성 문제(레이스 컨디션, 데드락 등)를 처리하기 위해 복잡한 동기화 메커니즘이 필요하지만, 단일 스레드 환경에서는 이런 문제를 자연스럽게 회피할 수 있습니다.
- 동시에 여러 스레드가 동일한 데이터를 수정하려고 할 때 발생할 수 있는 데이터 불일치 문제를 방지합니다.
- 모든 명령어가 순차적으로 처리되기 때문에, 복잡한 락(lock) 메커니즘 없이도 데이터의 일관성을 자연스럽게 유지할 수 있습니다.

<br>

---

<br>


## Redis는 주로 메모리 내에서 빠르게 수행되는 I/O 작업을 처리하는 인메모리 데이터베이스로 설계되어, 매우 빠른 응답 시간을 제공합니다. 
- 단일 스레드 이벤트 루프(event loop)를 사용함으로써 컨텍스트 스위칭(Context Switching)에 소요되는 오버헤드를 최소화할 수 있습니다.

<br>

---

<br>



## Redis는 이벤트 기반(event-driven) 아키텍처를 채택하여 네트워크 요청을 효율적으로 처리합니다. 
- 단일 스레드 이벤트 루프는 비동기적으로 여러 클라이언트의 요청을 처리할 수 있으며, 이를 통해 높은 동시성을 구현할 수 있습니다.
- 멀티스레드 모델에서는 이러한 비동기 처리의 이점을 충분히 활용하기 어려울 수 있습니다.



<br>

---

<br>



### Redis 6.0 부터 클라이언트로 부터 전송된 네트워크를 읽는 부분과 전송하는 I/O 부분은 멀티 스레드를 지원합니다. 
- 하지만 실행하는 부분은 싱글 스레드로 동작하기 때문에 기존과 같이 Atomic을 보장합니다.



> ## 추가설명


출처 : GPT


### **📌 Redis가 싱글 스레드인 이유**
**Redis는 왜 싱글 스레드로 동작할까?** 🤔

---

### **✅ 1. 싱글 스레드란?**  
- **싱글 스레드**: 하나의 CPU 코어에서 한 번에 하나의 작업만 처리하는 방식입니다.  
- **멀티 스레드**: 여러 개의 작업을 동시에 실행하는 방식입니다.  

Redis는 기본적으로 **싱글 스레드 방식**을 사용하지만, 내부적으로 최적화가 잘 되어 있기 때문에 **고성능을 유지할 수 있습니다.**  

---

### **✅ 2. Redis가 싱글 스레드를 사용하는 이유**  

### **1️⃣ I/O 멀티플렉싱을 활용한 빠른 요청 처리**  
Redis는 **"I/O 멀티플렉싱"** 기법을 사용하여 싱글 스레드에서도 여러 개의 클라이언트 요청을 동시에 처리할 수 있습니다.  

이는 Linux의 `epoll`, Mac의 `kqueue` 등의 비동기 이벤트 처리 방식을 활용하는 것으로, 요청이 들어오면 **비동기적으로 빠르게 처리**하는 방식입니다.  

✅ **예제 (일반적인 블로킹 방식 vs. Redis 방식)**  
```c
// 일반적인 블로킹 방식 (멀티스레드 필요)
int client_socket = accept(server_socket, NULL, NULL);
char buffer[1024];
recv(client_socket, buffer, sizeof(buffer), 0);  // 데이터 수신 (대기 발생)

// Redis의 비동기 방식 (싱글 스레드 + I/O 멀티플렉싱)
int epoll_fd = epoll_create(1);
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_socket, &event);
epoll_wait(epoll_fd, events, MAX_EVENTS, -1);  // 이벤트가 발생할 때만 처리
```
✔ **멀티플렉싱 덕분에 여러 요청을 대기 없이 빠르게 처리할 수 있습니다!** 🚀  

---

### **2️⃣ Redis의 연산은 "메모리 기반"이므로 CPU보다 메모리 속도가 중요함**  
- Redis는 **디스크 I/O보다 메모리 기반 연산을 주로 수행**합니다.  
- CPU 연산보다 메모리 접근 속도가 병목이 되는 경우가 많기 때문에, **멀티 스레드를 사용하지 않아도 충분히 빠르게 동작**합니다.  

✅ **예제: O(1) vs O(n) 연산 비교**
```redis
SET user:1 "Alice"       // O(1) - 즉시 저장
HSET user:1 age 25       // O(1) - 메모리 접근
LRANGE messages 0 -1     // O(n) - 리스트 전체 조회 (데이터 크기에 따라 느려질 수 있음)
```
✔ 대부분의 **Redis 연산은 O(1)이라 싱글 스레드에서도 매우 빠릅니다!**  

---

### **3️⃣ 멀티 스레드를 사용할 경우 오히려 성능이 저하될 수 있음**  
- 멀티 스레드 환경에서는 **동시에 같은 데이터를 처리할 때 "락(lock)"을 걸어야 합니다.**  
- Redis는 **싱글 스레드로 동작하기 때문에 락을 걸 필요가 없고**, 이 덕분에 성능이 일정하게 유지됩니다.  

✅ **예제: 멀티 스레드 환경에서 발생하는 락(lock) 문제**
```java
// 멀티 스레드 환경에서 락(lock) 필요
synchronized (redisInstance) {
    redisInstance.set("key", "value");  // 락이 걸려야 실행됨
}
```
✔ **싱글 스레드에서는 이러한 락을 걸 필요가 없으므로 더 빠르게 실행됩니다!** 🚀  

---

### **✅ 3. Redis는 100% 싱글 스레드인가?**  
사실 Redis는 100% 싱글 스레드 방식은 아닙니다.  

Redis 6.0부터 **네트워크 I/O 처리는 멀티 스레드**로 동작하며, **핵심 데이터 연산은 여전히 싱글 스레드로 유지**됩니다.  

📌 **싱글 스레드 vs 멀티 스레드 정리**
| 동작 방식 | 싱글 스레드 | 멀티 스레드 |
|---|---|---|
| **기본 데이터 처리 (GET, SET)** | ✅ O(1) | ❌ 락 필요 |
| **I/O 작업 (클라이언트 요청 수신/송신)** | ❌ 비효율적 | ✅ Redis 6.0 이후 멀티 스레드 |
| **디스크 저장 (RDB, AOF 백업)** | ❌ 느림 | ✅ 백그라운드 쓰레드 사용 |
| **기타 작업 (Pub/Sub, Lua 스크립트 실행 등)** | ✅ 빠름 | ❌ 락 필요 |

✔ **Redis 6.0부터는 네트워크 I/O는 멀티 스레드, 데이터 연산은 여전히 싱글 스레드 방식!**  

---

### **✅ 4. 결론**
💡 **Redis가 싱글 스레드인 이유는 "빠르고 안정적인 성능"을 유지하기 위해서입니다.**  
1️⃣ **I/O 멀티플렉싱을 사용하여 여러 요청을 동시에 처리할 수 있습니다.**  
2️⃣ **Redis는 주로 메모리 연산이므로, 멀티 스레드를 사용하지 않아도 성능이 충분히 빠릅니다.**  
3️⃣ **멀티 스레드를 사용하면 락(lock) 관리 비용이 발생하여 오히려 성능이 떨어질 수 있습니다.**  
4️⃣ **Redis 6.0부터 네트워크 I/O는 멀티 스레드 처리하지만, 핵심 데이터 연산은 여전히 싱글 스레드로 유지됩니다.**  

💡 **즉, Redis는 "싱글 스레드 + I/O 멀티플렉싱" 덕분에 빠른 성능을 유지하는 것입니다!** 🚀
