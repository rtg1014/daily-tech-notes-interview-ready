## JWT(Json Web Token) 
- JWT(Json Web Token) 은 통신 정보를 JSON 형식을 사용하여 안전하게 전송하기 위해 사용됩니다.
- JWT는 토큰 자체에 정보가 포함되어 있는 클레임 기반 토큰입니다. 일반적인 애플리케이션에서 JWT는 주로 인증과 인가를 구현하기 위해 사용됩니다.
- JWT는 헤더, 페이로드, 시그니처로 구분됩니다. 헤더에는 토큰의 암호화 알고리즘이나 타입을 가지며, 페이로드에는 데이터(만료일, 사용자 정보 등)을 가집니다.
- 시그니처는 헤더와 페이로드가 변조되지 않았는지 판단하기 위해 사용되는데요. 헤더와 페이로드를 비밀 키를 사용하여 헤더에 명시된 암호화 알고리즘으로 암호화하여 시그니처가 만들어집니다.


<br>

---

<br>

## JWT를 사용하여 인가를 구현하는 경우
- 클레임 기반 토큰의 특성 덕분에 세션 기반 인증에 비해서 사용자 정보를 조회하기 위한 추가적인 작업이 필요하지 않습니다.
- 또한, 서버가 상태를 관리하지 않기 때문에 서버가 이중화된 환경에서도 사용자의 로그인 정보를 일관성 있게 관리할 수 있습니다. (세션 불일치 문제가 발생하지 않습니다.)

<br>

하지만 JWT를 사용하는 경우, 몇 가지 주의 사항이 존재합니다.

## 주의 사항
- JWT는 디코딩이 쉽습니다. Base64로 디코딩하면 페이로드를 확인할 수 있습니다. 따라서, 민감한 정보를 담는 것에 유의해야 합니다.
  
- 시크릿 키의 복잡도가 낮은 경우, 무작위 대입 공격(Brute force Attack)에 노출될 수 있습니다. 따라서, 강력한 시크릿 키를 사용하는 것이 권장됩니다.
  
- 시크릿 키는 유출되면 안되기 때문에 안전한 공간에 관리해야합니다.
  
- JWT 탈취에 유의해야 합니다. 이를 위해서 JWT 저장 공간, 리프레시 토큰 도입 여부, Refresh Token Rotation, 탈취 감지 및 대응에 대해서 고민이 필요합니다.
  
- 토큰의 잦은 갱신이 사용자 경험을 저해하는지 고려해야 합니다. 예를 들어, 사용자가 게시글을 3시간 동안 작성하고 제출했지만 JWT가 만료되어 사용자가 작성한 글은 사라질 수 있습니다.

- 이를 해결하기 위해서 슬라이딩 세션과 같은 전략을 고민해 볼 수 있습니다.

- JWT none 알고리즘 공격을 유의해야 합니다. 공격자가 토큰의 헤더에 명시된 알고리즘을 none으로 변경하여, 페이로드가 변조되어도 시그니처 검증을 우회할 수 있습니다.

- 이를 해결하기 위해서 none 알고리즘 공격을 예방한 라이브러리를 사용하거나, none 알고리즘과 같이 약한 알고리즘에 대해서 필터링하는 등 주의가 필요합니다.


---
---

> ## 추가자료

코딩애플 - JWT 대충 쓰면 님들 코딩인생 끝남 

링크 : https://www.youtube.com/watch?v=XXseiON9CV0

### **📌 JWT 회원 인증의 보안 이슈와 해결 방법**  
📢 **JWT를 이용한 회원 인증을 구현할 때 보안상의 허점이 많을 수 있습니다.**  
**"그냥 따라 하면 큰일 날 수도 있다!"** 🔥  
이번 내용에서는 **JWT의 기본 원리**부터 **보안 이슈 & 해결 방법**까지 정리해 보겠습니다.  

---

# **📌 회원 인증 기본 개념**
> **로그인 기능의 핵심 원리**  
✔ **로그인한 유저에게 "입장권(Token)"을 발급**  
✔ 이후 유저가 사이트에서 요청할 때마다 **입장권을 제시**  
✔ 서버가 입장권을 검사 후 **유효하면 서비스 제공**  

📌 **인증 방식 비교**  

| 인증 방식 | 입장권(토큰)의 특징 | 검증 방식 | 장점 | 단점 |
|----------|-----------------|----------|------|------|
| **세션 방식** | 단순한 ID 저장 (번호, 세션 ID) | 서버의 세션 저장소에서 확인 | 보안성이 높음, 서버에서 강제 만료 가능 | 서버가 저장소를 관리해야 함 (부하 증가) |
| **JWT 방식** | 사용자 정보 + 유효기간 저장 | 토큰 자체만 검증 | 서버 부하 적음 (스테이트리스) | 보안이 취약할 수 있음, 토큰 탈취 시 문제 발생 |

✔ **세션 방식**은 서버에 저장소가 필요하지만 **보안성이 높음**  
✔ **JWT 방식**은 서버 부하가 적지만 **보안 이슈가 많을 수 있음**  

---

# **📌 JWT 토큰의 구조**
✔ JWT는 **Header + Payload + Signature**로 구성됨  

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJ1c2VySWQiOiIxMjM0NTYiLCJuYW1lIjoiSm9obiBEb2UiLCJleHAiOjE2OTAyMjI0MDB9.
H6aR4h9yzJp4wMLdsJ4RfdcAD1pXhBdINOF8fsHgZxU
```

| **구성 요소** | **설명** |
|--------------|---------|
| **Header** | 알고리즘 정보 저장 (예: HS256) |
| **Payload** | 사용자 정보 & 만료 시간 등 저장 (Base64 인코딩) |
| **Signature** | 시크릿 키를 사용하여 서명 (변조 방지) |

✔ **Payload에 유저 정보를 담고 있지만, 누구나 디코딩할 수 있음!**  
✔ 서명을 통해 변조 여부는 확인 가능하지만 **민감한 정보 보호는 불가능**  

---

# **📌 JWT의 보안 이슈 & 해결 방법**
## **1️⃣ `alg: none` 알고리즘 공격** 🚨
### **⚠️ 문제점**
JWT 헤더의 `alg`(알고리즘)를 `none`으로 설정하면 **서명을 검증하지 않음**  
→ **악성 유저가 직접 토큰을 만들어 서버에 제출할 수도 있음**  

### **✅ 해결 방법**
✔ `alg: none`을 사용하는 토큰을 거부하도록 설정  
✔ 최신 JWT 라이브러리 사용 시 대부분 자동으로 차단됨  

---

## **2️⃣ JWT는 디코딩이 쉬움** 🧐
### **⚠️ 문제점**
JWT의 Payload는 **Base64 URL 인코딩**되어 있지만 **누구나 쉽게 디코딩 가능**  
→ **사용자 이메일, 유저 ID 등의 정보를 JWT에 그대로 넣으면 안됨!**  

### **✅ 해결 방법**
✔ 민감한 정보(ID, 이메일 등)는 JWT에 직접 포함하지 않음  
✔ 사용자 정보가 필요할 경우 **DB에서 조회**하는 방식으로 변경  

---

## **3️⃣ 약한 시크릿 키 사용 문제** 🔑
### **⚠️ 문제점**
JWT의 서명(Signature)은 **시크릿 키**를 사용하여 생성  
→ **시크릿 키가 짧거나 약하면 브루트포싱 공격에 쉽게 뚫릴 수 있음**  

📢 **실제로 이런 일이 발생한 적이 있음!**  
유명 블로그/유튜브에서 공개된 시크릿 키를 공격에 이용해 성공률이 높았던 사례가 있음 😱  

### **✅ 해결 방법**
✔ **강력한 시크릿 키 사용 (64자 이상, 복잡한 랜덤 문자열)**  
✔ JWT 생성용 키와 검증용 키를 **분리해서 운영**  

```bash
# 강력한 시크릿 키 예제
openssl rand -base64 64
```

---

## **4️⃣ JWT 탈취 & 무제한 사용 문제** 🕵️‍♂️
### **⚠️ 문제점**
JWT는 **한 번 발급되면 만료 시간이 지나기 전까지 유효**  
→ **토큰이 탈취되면 만료될 때까지 무제한 사용 가능!**  

### **✅ 해결 방법**
✔ **보안이 강력한 저장소 (HttpOnly Cookie 등)에 저장**  
✔ **토큰 블랙리스트 (Blacklist) 운영**  
✔ **JWT 유효 기간을 짧게 설정 (예: 5분 이하)**  
✔ **리프레시 토큰(Refresh Token) 사용 → 짧은 토큰 자동 갱신**  

---

# **📌 JWT 보안 강화 솔루션**
## ✅ **1. 토큰 보관 위치 선택**
✔ **보안이 강력한 쿠키 (HttpOnly, Secure Cookie) 사용**  
✔ **LocalStorage에 저장하는 것은 보안상 위험 (XSS 공격 가능성)**  

## ✅ **2. 블랙리스트(Blacklist) 운영**
✔ 유효한 JWT 토큰 리스트를 관리하여 **탈취된 토큰을 강제 만료**  
✔ 하지만, 이 방식은 세션 방식과 유사하게 동작하므로 JWT의 장점(스테이트리스)이 사라질 수 있음  

## ✅ **3. 짧은 토큰 유효 기간 설정 + 리프레시 토큰 사용**
✔ **JWT 토큰을 5분 이내로 짧게 유지**  
✔ **리프레시 토큰(Refresh Token)**을 사용하여 짧은 만료 기간을 보완  
✔ **리프레시 토큰을 1회용으로 설정하여 안전성 강화 (토큰 로테이션)**  

### **리프레시 토큰 로테이션 예제 (Java Spring Security)**
```java
public String generateRefreshToken(String userId) {
    return Jwts.builder()
        .setSubject(userId)
        .setIssuedAt(new Date())
        .setExpiration(new Date(System.currentTimeMillis() + REFRESH_TOKEN_EXPIRATION))
        .signWith(SignatureAlgorithm.HS256, REFRESH_SECRET)
        .compact();
}

// 리프레시 토큰 사용 시 새 액세스 토큰 발급
public String refreshAccessToken(String refreshToken) {
    Claims claims = Jwts.parser()
        .setSigningKey(REFRESH_SECRET)
        .parseClaimsJws(refreshToken)
        .getBody();
    
    return generateAccessToken(claims.getSubject());
}
```

---

# **📌 JWT vs 세션 방식 - 언제 사용해야 할까?**
✔ **대부분의 서비스는 "세션 방식"이 적절함**  
✔ **JWT는 다음과 같은 경우에만 고려**  
  - **회원 수가 1억 명 이상 → 세션 저장 부담이 클 때**  
  - **마이크로서비스 아키텍처(MSA)에서 인증을 분산 처리할 때**  

📌 **보안이 중요한 서비스에서는 JWT 단독 사용을 지양**  
✔ JWT 단독 사용보다는 **세션 방식과 결합**하거나 **다른 인증 솔루션 사용**  

---

# **📌 결론**
✔ **JWT는 무작정 따라 쓰면 보안상 심각한 허점이 생길 수 있음**  
✔ **JWT의 보안 이슈를 반드시 고려하고 설계해야 함**  
✔ **보안이 중요한 서비스에서는 JWT 단독 사용을 피하고 보완 기법을 적용**  
✔ **언제나 새로운 기술을 도입할 때 장점과 단점을 분석한 후 도입할 것!** 🚀

---

🎯 **JWT를 무작정 사용하지 말고, 보안 이슈를 충분히 고려한 후 도입하세요!** 🛡

