## 해시(Hash)
- 해시(Hash)자료 구조는 키값 쌍으로 이루어진 데이터 구조로 키를 이용해 값을 O(1) 시간 복잡도로 찾을 수 있습니다.
- 해시 자료 구조는 키를 해시 함수에 넣어서 나오는 결과를 기반으로 값을 관리하는데요.
- 해시 함수는 다른 키를 사용해도 같은 결과가 나오는 경우가 존재합니다. 이를 해시 충돌(Hash Collision) 이라고 합니다.

<br>

---

<br>


## 해시 충돌은 어떻게 완화할 수 있나요? 
- 해시 충돌을 완화하기 위한 접근 방법으로 개방 주소법과 분리 연결법이 대표적인데요.


- 개방 주소법(Open Addressing) 은 특정 값이 들어가야 하는 자리(버킷)가 이미 사용되고 있는 경우 다른 해시 버킷에 데이터를 삽입하는 반면, 
- 분리 연결법(Separate Chaining) 은 버킷을 연결 리스트나 트리 형태로 관리하여 버킷에 들어갈 값의 수에 제한을 두지 않도록 하여 충돌을 완화합니다.



---

<br>



## 개방 주소법에서 다른 해시 버킷을 찾기 위한 방법에는 어떤 것이 존재하나요? 
- 버킷이 이미 사용되고 있는 경우, 다른 해시 버킷을 찾기 위한 여러 방법이 존재합니다.
- 선형 탐사법, 제곱 탐사법, 이중 해싱이 이에 해당됩니다.




---

<br>



### 선형 탐사법(Linear Probing) 은 임의의 고정된 크기만큼 한 칸씩 옮기면서 빈 버킷을 찾는 방법입니다. 
- 선형 탐사법은 특정 버킷 주변이 모두 채워져 있는 경우 해시 성능이 저하될 수 있습니다. (1차 군집 현상)
- 따라서, 해당 접근 방법은 해시 자료 구조 전체에 해시 충돌이 균등하게 발생할 때 유용합니다.


### 제곱 탐사법(Quadratic Probing) 은 선형 탐사법처럼 한 칸씩 찾는 것이 아닌 제곱으로 늘리면서 빈 버킷을 찾습니다. 
- 보폭이 점점 늘어나기 때문에 선형 탐사법처럼 특정 영역에 값이 밀집되어 저장되어도 해당 영역을 빠르게 벗어날 수 있습니다.
- 하지만, 여러 값이 해시 함수로 같은 값을 갖게 될 경우 모두 같은 순서로 탐사할 수밖에 없어 비효율적인 상황이 발생할 수 있습니다. (2차 군집 현상)



### 이중 해싱(Double Hashing) 은 해시 충돌이 발생하는 경우, 보조 해시 함수를 사용하는 방법입니다. 
- 해당 방법은 해시 충돌 가능성이 가장 작지만, 추가적인 보조 해시 함수에서 연산이 발생하기 때문에 다른 방식에 비해 많은 연산량이 요구됩니다.


<br>

---
---



<br>


> ## 추가학습자료

10분 테코톡] 👩‍🏫코니의 #️⃣Hash Function
출처 : https://www.youtube.com/watch?v=Rpbj6jMYKag


### **해시 테이블과 해시 함수 개념 정리 및 요약**

#### **1. 자료 저장과 자료 구조 선택의 중요성**
- 프로그래밍에서는 자료를 저장하는 일이 많고, 적절한 자료 구조를 선택하는 것이 중요하다.
- 배열을 사용하면 **검색 및 저장 시 O(n)의 시간복잡도**가 발생하는 문제가 있음.
- 트리(예: 레드-블랙 트리)를 사용하면 **O(log n) 시간복잡도**로 성능을 개선할 수 있음.
- 하지만 **자료가 많아지면 여전히 효율적이지 못함** → 더 빠른 자료 저장 및 검색 방법이 필요함.

#### **2. 해시 테이블이란?**
- 해시 테이블은 **해시 함수를 이용하여 데이터를 저장하는 자료 구조**다.
- 검색 및 저장 연산을 **O(1)의 평균 시간복잡도**로 처리할 수 있음.
- 해시 함수의 결과 값(해시 값)을 **인덱스(주소)로 사용하여 데이터를 저장**하는 방식.

#### **3. 해시 테이블의 동작 원리**
1. 데이터를 저장할 때 해시 함수를 적용하여 **해시 값을 계산**.
2. 해당 해시 값을 **배열의 인덱스로 사용하여 데이터 저장**.
3. 검색 시에도 해시 함수를 적용하여 **즉시 해당 위치에서 데이터를 찾음**.

✅ **예제**
```java
// 해시 함수: x를 14로 나눈 나머지를 주소로 사용
int hashFunction(int x) {
    return x % 14;
}

// 예시 데이터 저장
int[] hashTable = new int[14];
hashTable[hashFunction(7)] = 7;  // 7을 저장 (7 % 14 = 7번 인덱스)
hashTable[hashFunction(13)] = 13; // 13을 저장 (13 % 14 = 13번 인덱스)
```

#### **4. 해시 테이블의 장점**
- **배열이나 트리보다 빠르게 데이터를 검색 및 저장**할 수 있음.
- 저장된 데이터를 **비교할 필요 없이 즉시 접근 가능**.

#### **5. 해시 함수와 해시 충돌**
##### 1️⃣ **해시 함수의 조건**
- **계산이 단순해야 함**: 너무 복잡하면 저장/검색 속도가 느려짐.
- **해시 값이 균등하게 분포해야 함**: 특정 값들이 몰리지 않도록 설계.
- **해시 충돌을 최소화해야 함**: 서로 다른 값이 같은 해시 값을 가질 경우 문제가 발생.

##### 2️⃣ **해시 충돌(Hash Collision)**
- 해시 충돌이란 **다른 입력값이 같은 해시 값을 가질 경우 발생**.
- 예를 들어, `hashFunction(7) = 7`, `hashFunction(21) = 7`이면 두 개의 값이 같은 위치를 차지하려고 함.

✅ **예제**
```java
int hashFunction(int x) {
    return x % 7;  // 7로 나눈 나머지를 해시 값으로 사용
}

System.out.println(hashFunction(7));  // 0
System.out.println(hashFunction(21)); // 0 (충돌 발생)
```

#### **6. 해시 충돌 해결 방법**
##### **(1) 체이닝(Chaining) 방법**
- 같은 해시 값을 가지는 데이터를 **연결 리스트로 연결**하여 저장.
- 검색 시 해당 **연결 리스트를 순회하며 찾음**.

✅ **예제**
```java
import java.util.LinkedList;

class HashTable {
    private LinkedList<Integer>[] table;

    public HashTable(int size) {
        table = new LinkedList[size];
        for (int i = 0; i < size; i++) {
            table[i] = new LinkedList<>();
        }
    }

    public void insert(int key) {
        int index = key % table.length;
        table[index].add(key);
    }

    public boolean search(int key) {
        int index = key % table.length;
        return table[index].contains(key);
    }
}

public class Main {
    public static void main(String[] args) {
        HashTable hashTable = new HashTable(7);
        hashTable.insert(7);
        hashTable.insert(21);  // 7과 같은 해시 값 → 같은 리스트에 저장
        System.out.println(hashTable.search(7));  // true
        System.out.println(hashTable.search(21)); // true
    }
}
```

##### **(2) 개방 주소법 (Open Addressing)**
- **해시 충돌 발생 시 다른 빈 공간을 찾아 저장**.
- 대표적인 방법:
  1. **선형 조사(Linear Probing)** → 다음 빈 공간에 저장.
  2. **이차 조사(Quadratic Probing)** → 점프 간격을 증가시키면서 저장.
  3. **이중 해싱(Double Hashing)** → 다른 해시 함수를 추가로 사용.

✅ **선형 조사(Linear Probing) 예제**
```java
int size = 7;
int[] table = new int[size];

int hashFunction(int x) {
    return x % size;
}

void insert(int key) {
    int index = hashFunction(key);
    while (table[index] != 0) {  // 충돌 발생 시 다음 자리로 이동
        index = (index + 1) % size;
    }
    table[index] = key;
}
```

✅ **이중 해싱(Double Hashing) 예제**
```java
int hashFunction1(int x) {
    return x % size;
}

int hashFunction2(int x) {
    return 5 - (x % 5);  // 5로 나눈 나머지를 보정하여 새로운 점프 크기 생성
}

void insert(int key) {
    int index = hashFunction1(key);
    int stepSize = hashFunction2(key);

    while (table[index] != 0) {
        index = (index + stepSize) % size;
    }
    table[index] = key;
}
```

#### **7. 해시 함수의 특징**
- **항상 동일한 입력에 동일한 해시 값 출력**.
- **입력값이 미세하게 달라져도 완전히 다른 해시 값이 생성**.
- **1방향 함수(역연산 불가능)** → 보안성이 뛰어남.

#### **8. SHA 해시 함수**
- 대표적인 해시 알고리즘: **SHA(Secure Hash Algorithm)**
- **SHA-256**은 256비트의 해시 값을 생성하며, 충돌 가능성이 매우 낮음.

✅ **SHA-256 해시 예제 (Java)**
```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class SHA256Example {
    public static void main(String[] args) throws NoSuchAlgorithmException {
        String input = "Hello, World!";
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] hash = md.digest(input.getBytes());

        StringBuilder hexString = new StringBuilder();
        for (byte b : hash) {
            hexString.append(String.format("%02x", b));
        }
        System.out.println("SHA-256 Hash: " + hexString.toString());
    }
}
```

#### **9. 해시 함수의 활용 사례**
- **데이터 무결성 검사**: 파일이 변조되었는지 확인.
- **비밀번호 저장**: 원본 비밀번호 대신 해시 값 저장.
- **블록체인**: 거래 내역의 보안 및 신뢰성 보장.
- **검색 최적화**: 빠른 데이터 탐색을 위해 사용.

---

### **📌 결론**
- 해시 테이블은 **O(1)의 시간복잡도로 빠르게 검색 및 저장 가능**.
- 하지만 **해시 충돌 문제**가 발생할 수 있어 **체이닝, 개방 주소법** 등을 활용해야 함.
- **SHA-256 같은 보안 해시 함수**는 데이터 무결성 및 보안을 위해 널리 사용됨.
- **해시 테이블은 알고리즘 최적화 및 데이터 관리에서 필수적인 자료구조**이다.



