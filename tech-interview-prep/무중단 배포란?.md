## 무중단 배포(Zero-Downtime Deployment)
- 무중단 배포(Zero-Downtime Deployment)는 서비스에 다운 타임이 발생하지 않으면서, 새로운 버전의 애플리케이션을 서버에 배포하는 것을 의미합니다.
- 무중단 배포 패턴에는 대표적으로 순차적으로 배포하는 롤링 배포, 전체 서버를 통째로 바꾸는 블루/그린 배포, 트래픽을 순차적으로 이동시키는 카나리 배포가 존재합니다.

---

<br>

## 각 배포 방식이란? 
### 롤링 배포(Roling Deployment) 
- 롤링 배포(Roling Deployment) 는 서버를 한 대씩 순차적으로 업데이트하는 가장 기본적인 방식입니다.
- 특정 시점에는 두 가지 버전이 공존하기 때문에 새로운 버전은 기존 버전 기능을 지원하는 등 하위 호환성(Backward Compatibility) 에 신경을 써야 합니다.
- 롤링 배포는 새로운 버전을 배포하기 위해서 새로운 서버를 생성하지 않습니다. 배포가 진행 중인 서버는 요청 처리가 불가하기 때문에 다른 서버에 전달되는 트래픽이 증가할 수 있습니다.


---

<br>

### 블루/그린 배포(Blue/Green Deployment) 
- 블루/그린 배포(Blue/Green Deployment) 는 기존의 서버와 동일한 스펙과 사이즈의 서버를 미리 준비하고, 신규 버전을 배포한 이후에 기존 서버는 폐기하고 트래픽을 신규 버전의 서버로 이전 시키는 방법입니다.
- 블루/그린 배포의 경우에는 기존의 버전을 가지고 있기(폐기 이전이라 가정) 때문에 롤백을 빠르게 수행할 수 있습니다.
- 하지만, 배포 과정에서 새로운 서버를 미리 준비해야 한다는 점에서 비용이 발생할 수 있습니다.

---

<br>

### 카나리 배포(Canary Deployment) 
- 카나리 배포(Canary Deployment) 는기존 버전의 서버와 새로운 버전의 서버들을 구성한 이후, 전체 트래픽의 퍼센티지로 관리하는 방법입니다.
- 예를 들어 트래픽을 기존 서버 70퍼, 신규 서버 30퍼로 나누고 점점 신규 서버로 트래픽을 보내어 나중엔 신규 서버가 100퍼센트가 되어 배포가 완료됩니다.
- 롤링 배포처럼 특정 시점에 다른 두 버전의 서버가 공존하기 때문에 하위 호환성을 신경 써야 합니다.

---

<br>


## 어떤 상황에 각 배포 전략을 선택할 수 있을까요? 
- 배포를 위해 새로운 서버를 생성하는 비용을 감수하기 어려운 경우, 롤링 배포를 선택할 수 있습니다.
- 또한, 서버 API 구간에서 버그가 생겼을 때 이것을 수정하고 개발 서버에서 충분히 테스트한 이후 상용에 올려보고 싶을 때 롤링 배포가 유용할 수 있습니다.
- 서버 10대 중 1대만 버그를 수정해서 배포하고 디버그 레벨로 로깅을 하면서 수정한 버그가 해결됐는지 확인합니다.
- 만약 실제 상용 서버에서도 문제가 없다면 1대씩 순차적으로 롤링 배포를 진행합니다.


- 대규모 업데이트가 있을 때는 블루/그린 배포를 선택할 수 있습니다.
- 예를 들어 전면적으로 기술 부채가 해결되거나 중요한 변화가 있을 때, 비용을 감수하고 블루/그린 배포를 채택하는 것이 유용할 수 있습니다.
- 카나리 배포는 통계적으로 무언가 확인하고 싶은 것 (오류율, 성능)이 있을 때, 혹은 A/B 테스트를 하고 싶을 때 채택할 수 있습니다.

<br>

---
---
---

<br>


> ## 추가학습자료

<br>


[10분 테코톡] 테니의 무중단 배포
출처 : https://www.youtube.com/watch?v=kgvBlruQEKU

<br>
<br>

### 🚀 **무중단 배포와 안정적인 서비스 종료**  

**무중단 배포(Zero Downtime Deployment)**에 대해 알아보겠습니다. 무중단 배포가 **왜 필요한지, 어떻게 작동하는지, 
그리고 서비스를 종료할 때 안정성을 보장하는 방법**을 정리합니다.

---

## 📌 **1. 무중단 배포란?**
`무중단 배포(Zero Downtime Deployment)`는 서비스 중단 없이 새로운 버전의 애플리케이션을 배포하는 방법입니다.  

### 💡 **무중단 배포가 왜 필요할까요?**
서비스가 중단되면 **사용자가 기능을 사용할 수 없고, 비즈니스에 직접적인 피해**를 줄 수 있기 때문입니다.

#### 🎯 **예시: 가위바위보 서비스중 "안 내면 진다" 기능 출시 중 다운타임 발생**
- 사용자가 기능을 이용하려고 하는데, 배포 중 다운타임이 발생해 참여를 못 함  
- 몇 초만 지나면 다시 정상 동작하지만, **사용자는 이미 불편을 겪음**  
- 이런 상황을 방지하기 위해 **무중단 배포가 필요함**

🚧 **"다운타임(Downtime)"** 이란?  
- 애플리케이션 배포 과정에서 **기존 서버가 내려가고, 새로운 버전이 올라오는 사이의 공백 시간**  
- 사용자가 이 시간 동안 서비스를 이용하지 못함  

---

## 🛠 **2. 무중단 배포 방식**
무중단 배포를 위해서는 **최소 2대 이상의 서버**가 필요합니다.  
서버 하나가 배포되는 동안, 다른 서버가 계속 요청을 처리해야 하기 때문입니다.  

대표적인 **무중단 배포 방식 3가지**를 살펴보겠습니다.

### 🟢 **1) 롤링 배포 (Rolling Deployment)**
✔️ **방식:**  
- 서버를 하나씩 새로운 버전으로 교체하는 방식  
- 기존 서버의 트래픽을 차단 → 새로운 버전 배포 → 트래픽 재개  
- 여러 서버에 **순차적으로 적용**하여 다운타임을 줄임  

✔️ **장점:**  
- 새로운 서버를 추가로 배포하지 않아도 됨 (리소스 절약)  
- 작은 변화가 있을 때 안정적으로 적용 가능  

✔️ **단점:**  
- 배포 중에는 **기존 버전과 새 버전이 공존**하기 때문에, **호환성 문제 발생 가능**  
- 배포 중인 서버는 요청을 받을 수 없으므로, **트래픽 부하가 증가할 위험 있음**  

#### 🎯 **비유: "음식점 테이블 교체하기"**  
- 손님이 앉아 있는 테이블을 하나씩 교체하는 방식  
- 기존 손님이 있는 상태에서 새로운 테이블로 변경하므로 **전환 과정에서 약간의 불편**이 있을 수 있음  

---

### 🔵 **2) 블루/그린 배포 (Blue-Green Deployment)**
✔️ **방식:**  
- 기존 서버(Blue)와 새로운 서버(Green)를 **완전히 분리**  
- 새로운 버전을 **Green 서버에 배포 후 테스트**  
- **트래픽을 기존 서버(Blue) → 새로운 서버(Green)으로 한 번에 전환**  

✔️ **장점:**  
- **배포 후 테스트 가능** → 실제 트래픽을 받기 전에 검증 가능  
- 롤백이 매우 빠름 (트래픽을 다시 Blue로 돌리면 됨)  

✔️ **단점:**  
- **서버를 2배로 운영해야 함** (비용 증가)  

#### 🎯 **비유: "새로운 매장 오픈하기"**  
- 기존 매장(Blue)에서 영업 중이고, **옆 건물(Green)에 새 매장을 완벽하게 준비**  
- 준비가 끝나면 **고객을 새로운 매장으로 안내**  
- 만약 문제가 생기면 다시 기존 매장(Blue)으로 돌아가면 됨  

---

### 🟡 **3) 카나리 배포 (Canary Deployment)**
✔️ **방식:**  
- **소수의 사용자(일부 트래픽)만 새로운 버전으로 전환**  
- 점진적으로 트래픽을 늘려가며 **문제가 발생하는지 테스트**  
- 안정성이 확인되면 **전체 트래픽을 새로운 버전으로 전환**  

✔️ **장점:**  
- **문제 발생 시 영향이 제한적** → 일부 사용자에게만 영향  
- **A/B 테스트 가능** → 사용자 반응을 살펴볼 수 있음  

✔️ **단점:**  
- 트래픽 분배 설정이 필요 (로드 밸런서 또는 프록시 서버 활용)  
- 전체 적용까지 시간이 걸릴 수 있음  

#### 🎯 **비유: "새로운 레시피 테스트"**  
- 기존 메뉴를 팔면서, **일부 단골 손님에게 새로운 메뉴를 시식**  
- 반응이 좋으면 점진적으로 모든 손님에게 제공  
- 반응이 나쁘면 기존 메뉴만 유지  

---

## ⏳ **3. 서비스 종료 시 안정성 보장하기 (Graceful Shutdown)**
배포뿐만 아니라, **서버를 종료할 때도 안전한 방식이 필요**합니다.  
잘못 종료하면 **처리 중이던 요청이 사라지고, 사용자 경험이 나빠질 수 있습니다.**  

### ❌ **Hard Shutdown (즉시 종료)**
✔️ **방식:**  
- 요청을 처리 중이더라도 **강제 종료**  
- 실행 중이던 요청이 중단되고, 클라이언트는 **응답을 받지 못함**  

✔️ **문제점:**  
- 데이터 손실 위험  
- 사용자가 예상치 못한 오류를 경험할 가능성 높음  

#### 🎯 **비유: "식당 영업 중 갑자기 불 끄고 문 닫기"**  
- 손님이 음식을 먹고 있는데, **갑자기 불이 꺼지고 가게 문이 닫힘**  
- 손님은 음식을 다 먹지도 못한 채 나가야 함  

---

### ✅ **Graceful Shutdown (우아한 종료)**
✔️ **방식:**  
- 현재 처리 중인 요청이 끝날 때까지 기다린 후 종료  
- 새로운 요청은 받지 않음  
- **일정 시간이 지나도 처리가 끝나지 않으면 강제 종료**  

✔️ **장점:**  
- 요청이 정상적으로 끝난 후 서버 종료 가능  
- 클라이언트가 예상치 못한 오류를 경험하지 않음  

✔️ **설정 방법 (Spring)**  
- `application.yml`에 설정 추가  
  ```yaml
  server:
    shutdown: graceful
  spring:
    lifecycle:
      timeout-per-shutdown-phase: 10s
  ```
- 위 설정을 적용하면, **서버가 종료 요청을 받아도 10초 동안 현재 요청을 완료한 후 종료**  

#### 🎯 **비유: "식당 문 닫기 전에 손님 다 먹을 때까지 기다리기"**  
- "곧 영업이 종료됩니다. 지금 계산해주세요!"  
- **현재 손님이 다 먹고 나갈 때까지 기다린 후 문 닫기**  
- 더 이상 새 손님은 받지 않음  

---

## 🎯 **마무리 요약**
| 배포 방식 | 특징 | 장점 | 단점 |
|-----------|------|------|------|
| **Rolling** | 서버를 하나씩 교체 | 새로운 자원 필요 없음 | 기존 버전과 공존하여 호환성 문제 발생 가능 |
| **Blue-Green** | 새 서버에 배포 후 트래픽 전환 | 빠른 롤백 가능 | 서버 2배 운영 필요 |
| **Canary** | 일부 사용자에게 먼저 배포 | 안정성 높고, 문제 감지 가능 | 전체 적용까지 시간 소요 |

🚨 **서비스 종료 시**  
- **Hard Shutdown** ❌ → 요청이 끊기고, 사용자 경험 악화  
- **Graceful Shutdown** ✅ → 요청이 끝날 때까지 기다린 후 종료  

---

## ✅ **정리**
무중단 배포는 **서비스 중단 없이 사용자에게 새로운 기능을 제공하는 핵심 기술**입니다.  
배포 방식은 **서비스 성격과 인프라 상황**에 따라 선택해야 하며, **안정적인 종료 방식(Graceful Shutdown)도 중요**합니다.

이제 배포할 때 "사용자가 불편하지 않도록" 신경 쓰는 개발자가 되어 보세요! 🚀

---

<Br><Br><Br><Br><Br><Br>


> ## 심화내용 추가 학습


<Br><Br><Br>


## 🚀 **무중단 배포(Zero Downtime Deployment)의 심층 분석과 기술 면접 대비**

무중단 배포(Zero Downtime Deployment)는 **서비스 중단 없이 새로운 버전의 애플리케이션을 배포하는 방법**입니다.  
하지만, 단순히 **"서버를 추가해서 트래픽을 전환하면 된다"** 수준의 이해로는 기술 면접에서 깊이 있는 답변을 하기가 어렵습니다.  

이번에는 기존 개념을 확장하여 **무중단 배포의 깊이 있는 원리, 고려해야 할 요소, 기술적인 어려움, 그리고 왜 특정 상황에서는 특정 방법을 써야 하는지**를 다루겠습니다.

---

# **1️⃣ 무중단 배포의 핵심 개념**
무중단 배포의 목적은 **배포 중에도 사용자가 불편함을 느끼지 않도록 서비스 가용성을 보장하는 것**입니다.  
그러나, 단순히 "서버 두 대를 운영하면 된다"는 식으로 접근하면 안 됩니다.  
무중단 배포는 **다양한 인프라 요소(로드 밸런서, 데이터베이스, 캐시, 네트워크 설정 등)가 유기적으로 작동해야 성공적으로 구현**될 수 있습니다.

## **📌 왜 무중단 배포가 어려운가?**
무중단 배포를 단순히 트래픽을 새 서버로 보내는 문제라고 생각하면 안 됩니다.  
실제 적용할 때는 **다음과 같은 문제들**을 해결해야 합니다.

### 🔥 **1. 롤링 배포 시 "버전 불일치" 문제**
- 롤링 배포는 **서버를 하나씩 업데이트**하기 때문에 일정 시간 동안 **구버전과 신버전이 공존**합니다.
- 만약 **API 스펙이 변경**되었거나, **데이터베이스 스키마 변경이 포함**되었다면, **구버전 서버가 새로운 DB를 참조하면서 오류가 발생할 가능성**이 있습니다.
- 이를 방지하려면 **API 백워드(Backward) 호환성을 유지**하거나, **데이터 마이그레이션 전략**을 사용해야 합니다.

🔹 **해결 방법:**  
1. **API 버전 관리 (Versioning)**  
   - API가 변경될 경우, 기존 API와 새로운 API를 **동시에 운영(V1, V2 API 제공)**  
   - 클라이언트가 새로운 API를 점진적으로 사용하도록 유도  
   
2. **DB 마이그레이션 시점 고려**  
   - 새로운 컬럼 추가 후, 기존 컬럼을 **즉시 제거하지 않고 일정 기간 유지**  
   - 트래픽이 완전히 새로운 버전으로 이동한 후, 구 데이터 제거  

---

### 🔥 **2. 블루-그린 배포 시 "데이터 일관성" 문제**
블루-그린 배포는 빠른 롤백이 가능하지만, **데이터 변경이 있는 경우 새로운 버전과 기존 버전 간 데이터 불일치**가 발생할 수 있습니다.

🔹 **예제:**  
- 블루 환경에서는 `users` 테이블에 `name, email` 컬럼만 존재  
- 그린 환경에서는 `phone_number` 컬럼이 추가됨  
- 그린 환경에서 `phone_number` 값을 사용하는데, **블루 환경으로 롤백하면 해당 데이터가 유실될 가능성**이 있음  

🔹 **해결 방법:**  
1. **DB 마이그레이션을 단계적으로 수행**  
   - 새로운 테이블/컬럼 추가 → 애플리케이션 업데이트 → 일정 기간 후 기존 컬럼 삭제  

2. **읽기/쓰기 분리 전략(Read-Write Splitting) 사용**  
   - **읽기(read) 요청**은 **이전 DB에서도 가능**하도록 보장  
   - **쓰기(write) 요청**은 새로운 테이블에서만 수행  
   - 롤백 시 데이터 변환(Transformation) 과정이 필요  

---

### 🔥 **3. 카나리 배포 시 "트래픽 라우팅" 문제**
카나리 배포는 **일부 사용자만 새로운 버전을 사용하도록 트래픽을 제한**합니다.  
하지만, **어떤 기준으로 트래픽을 분배할 것인지**가 중요합니다.

🔹 **트래픽 분배 기준**  
✅ 랜덤(Random) → 특정 비율의 사용자에게 새 버전을 제공  
✅ 지역 기반(Location-based) → 특정 지역 사용자만 새로운 버전 테스트  
✅ 사용자 그룹 기반(User Segmentation) → VIP 사용자에게만 적용  

🔹 **기술적 구현 방법:**  
- **로드 밸런서의 트래픽 분배 설정 (NGINX, AWS ALB 등)**  
- **Feature Toggle 기법 활용**  
  - 새 기능을 "켜고 끄는 스위치"처럼 관리  
  - 문제가 발생하면 **즉시 롤백 가능**  

---

# **2️⃣ 안정적인 서비스 종료 (Graceful Shutdown) 심화**
무중단 배포뿐만 아니라, **서버 종료 시 안정성을 보장하는 것도 중요한 요소**입니다.  
**요청이 처리 중인데 서버가 갑자기 꺼지면 오류 발생** → 사용자가 예기치 않은 경험을 하게 됨  

## **📌 Graceful Shutdown이 중요한 이유**
- 실행 중이던 **모든 요청을 안전하게 마무리**한 후 종료  
- 데이터가 **손실되지 않도록 보장**  
- 새로운 서버로 트래픽을 점진적으로 이동  

🔹 **예제: 서버 종료 시 문제 발생**  
1. 사용자가 결제를 진행하는 중  
2. 결제 요청이 서버로 전달되었지만, **서버가 즉시 종료됨 (Hard Shutdown)**  
3. **사용자는 결제가 완료되지 않았다고 생각하지만, 실제로는 처리됨** → **중복 결제 위험 발생**  

🔹 **해결 방법:**  
✅ **요청을 모두 처리한 후 서버 종료 (Graceful Shutdown 설정)**  
✅ **서버 종료 직전에 로드 밸런서에서 트래픽 제거**  
✅ **Active-Active 모델을 사용하여 요청을 다른 서버로 이동**  

🔹 **Spring에서 Graceful Shutdown 설정**
```yaml
server:
  shutdown: graceful
spring:
  lifecycle:
    timeout-per-shutdown-phase: 15s
```
→ 서버 종료 시 15초 동안 **현재 요청이 끝날 때까지 대기한 후 종료**

---

# **3️⃣ 무중단 배포 시 고려해야 할 요소들**
무중단 배포를 제대로 구현하기 위해서는 **단순히 서버 두 대를 운영하는 것뿐만 아니라 다양한 인프라 요소를 함께 고려해야 합니다.**

✅ **로드 밸런서 설정**
- 트래픽을 올바르게 분배하고, 다운된 서버로 요청이 가지 않도록 설정해야 함  
- **AWS ALB, Nginx, HAProxy 등** 활용  

✅ **세션 관리 (Session Management)**
- 무중단 배포 시 기존 사용자의 로그인 세션이 유지되어야 함  
- **세션 스토리지 방식 고려**  
  - **Sticky Session**: 특정 사용자의 요청을 항상 같은 서버로 유지  
  - **Redis 같은 외부 세션 저장소 활용**  

✅ **캐싱(Cache) 문제**
- 캐시된 데이터가 새로운 버전과 호환되지 않을 수 있음  
- 배포 시 캐시를 갱신하는 전략 필요  

✅ **Database Connection Pool 관리**
- 롤링 배포 중 DB 커넥션이 끊기면 일부 요청이 실패할 가능성이 있음  
- Connection Pool을 조절하여 **기존 DB 연결이 유지되도록 설정** 필요  

---

# **📌 마무리 정리**
✅ **무중단 배포 방식 비교**
| 배포 방식 | 장점 | 단점 | 사용 사례 |
|-----------|------|------|----------|
| **Rolling** | 서버 추가 없이 운영 가능 | 구버전과 신버전이 공존 (호환성 문제 발생 가능) | 트래픽이 많지 않고, 변경이 적은 경우 |
| **Blue-Green** | 빠른 롤백 가능, 신버전 검증 가능 | 서버 2배 운영 필요 (비용 증가) | 금융 시스템, 대규모 서비스 |
| **Canary** | 일부 사용자만 새로운 버전 적용 가능 | 트래픽 분배 설정 필요 | A/B 테스트, 신규 기능 출시 |

🔹 **무중단 배포 시 고려해야 할 핵심 요소**
- 데이터베이스 마이그레이션 전략  
- API 백워드 호환성 유지  
- 세션 관리 & 캐싱 문제 해결  
- Graceful Shutdown 적용  

🚀 **배포는 단순한 "서버 올리기"가 아니다!**  
👉 인프라, 데이터, 사용자 경험을 모두 고려하는 것이 **진정한 무중단 배포!**
