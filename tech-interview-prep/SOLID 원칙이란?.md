## SOLID 원칙
- SOLID 원칙은 객체지향 설계 5원칙이라고도 불리며, 각 원칙의 앞 글자를 따서 만들어졌습니다.
- 객체지향설계의 핵심 중 하나는 의존성을 관리하는 것인데요. 의존성을 잘 관리하기 위해서는 SOLID 원칙을 준수해야 합니다.

<br>

---

<br>

## 단일 책임 원칙(Single Responsibilty Principle) 
- 단일 책임 원칙(Single Responsibilty Principle) 은 클래스가 오직 하나의 목적이나 이유로만 변경되어야 한다는 것을 강조합니다.
- 여기서 “책임”이란 단순히 메서드의 개수를 뜻하지 않고, 특정 사용자나 기능 요구사항에 따라 소프트웨어의 변경 요청을 처리하는 역할을 의미합니다.
- 즉, 클래스는 한 가지 변화의 이유만 가져야 하며, 이를 통해 변경이 발생했을 때 다른 기능에 영향을 덜 미치도록 설계됩니다.
- 이렇게 하면 유지보수가 쉬워지고 코드가 더 이해하기 쉬워집니다.

<br>

---


## 개방 폐쇄 원칙(Open-Closed Principle) 
- 개방 폐쇄 원칙(Open-Closed Principle) 은 확장에는 열려있고, 변경에는 닫혀 있어야 함을 강조합니다.
- 이때 확장이란 새로운 타입을 추가함으로써 새로운 기능을 추가하는 것을 의미하며, 폐쇄란 확장이 일어날 때 상위 레벨의 모듈이 영향을 받지 않아야 함을 의미합니다.
- 이를 통해서 모듈의 행동을 쉽게 변경할 수 있습니다.
- 모듈이란 크기와 상관없이 클래스, 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미합니다.


<br>

---


## 리스코브 치환 원칙(Liskov Substitution Principle)
- 리스코브 치환 원칙(Liskov Substitution Principle)은 서브 타입은 언제나 상위 타입으로 교체할 수 있어야 합니다.
- 즉, 서브 타입은 상위 타입이 약속한 규약을 지켜야 함을 강조합니다. 이 원칙은 부모 쪽으로 업 캐스팅하는 것이 안전함을 보장하기 위해 존재합니다.
- 상위 타입에 대해 기대되는 역할과 행동 규약이 있는데 이를 벗어나면 안 됩니다.
- 만약, 하위 타입이 상위 타입에 기대되는 역할을 만족하지 않는다면, 상위 타입을 사용하는 클라이언트 코드에서는 하위 타입이 누구인지 물어봐야 하는데, 이는 OCP를 달성하기 어렵게 합니다.
- LSP를 위반하는 대표적인 사례로는 Rectangle 예제가 있습니다.


<br>

---

## 인터페이스 분리 원칙(Interface Segregation Principle)
- 인터페이스 분리 원칙(Interface Segregation Principle) 은 클라이언트 입장에서 인터페이스를 분리해야 함을 강조합니다.
- 사용하지 않지만 의존성을 가지고 있다면 해당 인터페이스가 변경되는 경우 영향을 받습니다. 따라서, 독립적인 개발과 배포가 불가합니다.
- 사용하는 기능만 제공하도록 인터페이스를 분리해 변경의 여파를 최소화할 수 있습니다.

<br>

---

## 의존성 역전 원칙(Dependency Inversion Principle)
- 의존성 역전 원칙(Dependency Inversion Principle) 은 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 되며, 모두 추상화에 의존해야 함을 강조합니다.
- SOLID는 서로 연관이 있는데요. 의존성 역전 원칙을 통해서 하위 레벨의 모듈은 개방 폐쇄 원칙을 준수하면서 새로운 타입이 추가 가능합니다.


---

<br>
<br>

## 앞으로 어떤 확장이 필요한지 완벽히 알아야 OCP를 제대로 할 수 있는 거 아닌가요?
- 변경을 예상하고, 준비하지 말고 고객이 원한 것만 만들어서 빨리 전달하고 피드백을 수용하는 방법을 사용해 볼 수 있습니다.
- 변화에 대한 가장 좋은 예측은 변화를 경험하는 것이라고 생각합니다. 발생할 것 같은 변화를 발견한다면 향후 해당 변화와 같은 종류의 변화로부터 코드를 보호할 수 있습니다.
- 즉, 고객이 요구할 모든 종류의 변경을 완벽하게 예측하고, 이에 대한 변경에 대응하기 위해 추상화를 적용하는 대신에 고객이 변경을 요구할 때까지 기다리고 추상화를 만들어서 향후 추가로 재발하는 변화로부터 보호될 수 있도록 하는 것입니다.
- 이때 OCP를 준수하도록 코드를 작성할 수 있습니다.

  
