## 컨텍스트 스위칭(Context Switching)이란?
- 컨텍스트 스위칭은 CPU나 코어에서 실행 중이던 프로세스나 스레드가 다른 프로세스나 스레드로 교체되는 과정을 말합니다.
- 이는 멀티태스킹 시스템에서 여러 작업을 효율적으로 관리하기 위해 필수적인 메커니즘입니다.

---

## 컨텍스트(Context)란?
- 컨텍스트는 프로세스나 스레드의 현재 상태를 의미합니다.
- 여기에는 CPU의 레지스터 상태(프로그램 카운터, 스택 포인터 등)와 메모리 상태가 포함됩니다.
- 컨텍스트는 프로세스나 스레드가 실행을 중단하고 나중에 다시 시작할 때 필요한 모든 정보를 담고 있습니다.

---



## 컨텍스트 스위칭이 필요한 이유
- 멀티태스킹 시스템에서는 여러 프로세스나 스레드가 동시에 실행되는 것처럼 보이도록, CPU가 짧은 시간 단위로 작업을 전환하며 여러 작업을 처리합니다.
- 이를 통해 사용자에게는 여러 작업이 동시에 진행되는 것처럼 인식되며, 시스템 자원을 효율적으로 활용할 수 있습니다.


---


## 컨텍스트 스위칭이 발생하는 시점
- Time Slice(Quantum)를 다 사용했을 때: 각 프로세스나 스레드에게 할당된 CPU 시간이 다 소진되면 스위칭이 발생합니다.
- I/O 작업이 필요할 때: 프로세스나 스레드가 I/O 작업을 수행해야 할 경우, CPU는 다른 작업을 처리하기 위해 현재 작업을 중단하고 스위칭을 수행합니다.
- 우선순위 변경: 더 높은 우선순위의 작업이 발생하면 현재 작업을 중단하고 우선순위가 높은 작업으로 전환할 수 있습니다.

---

## 컨텍스트 스위칭을 수행하는 주체
- 컨텍스트 스위칭은 운영체제의 커널(kernel) 에 의해 수행됩니다.
- 커널은 시스템 자원을 관리하고 프로세스 및 스레드의 상태를 조정하여 효율적인 작업 처리를 담당합니다.


---


## 컨텍스트 스위칭의 구체적인 과정

---

### 프로세스 컨텍스트 스위칭(다른 프로세스에 속한 스레드 간의 컨텍스트 스위칭)
- 현재 프로세스의 상태 저장: 실행 중인 프로세스의 레지스터 상태와 메모리 정보를 저장합니다.
- 다음 프로세스의 상태 로드: 스케줄러가 선택한 다음 실행할 프로세스의 저장된 상태를 로드합니다.
- 프로세스 전환: CPU는 새로운 프로세스의 실행을 시작합니다.
- 추가 메모리 처리: 새로운 프로세스의 가상 메모리 주소 체계를 설정하고, MMU(Memory Management Unit)와 TLB(Translation Lookaside Buffer)를 업데이트합니다.

---

### 스레드 컨텍스트 스위칭(같은 프로세스에 속한 스레드 간의 컨텍스트 스위칭)
- 현재 스레드의 상태 저장: 실행 중인 스레드의 레지스터 상태를 저장합니다.
- 다음 스레드의 상태 로드: 동일한 프로세스 내에서 실행할 다음 스레드의 상태를 로드합니다.
- 스레드 전환: CPU는 새로운 스레드의 실행을 시작합니다.
- 메모리 처리 생략: 동일한 프로세스 내 스레드 간 전환이므로 메모리 관련 추가 처리가 필요 없습니다.

---

## 프로세스와 스레드 컨텍스트 스위칭의 공통점
- 커널 모드에서 실행: 컨텍스트 스위칭은 항상 운영체제의 커널 모드에서 수행됩니다.
- CPU 레지스터 상태 교체: 현재 실행 중인 작업의 레지스터 상태를 저장하고, 다음 작업의 레지스터 상태를 복원합니다.

---

## 프로세스와 스레드 컨텍스트 스위칭의 차이점
- 같은 프로세스에 속한 스레드들 간의 컨텍스트 스위칭은 같은 프로세스에 속하기 때문에 메모리 영역을 공유합니다.
- 그래서 스위칭이 발생해도 메모리와 관련한 추가적인 작업이 발생하지 않습니다.
- 하지만 다른 프로세스에 속한 스레드 간의 컨텍스트 스위칭의 경우 메모리 프로세스간 메모리 주소 체계가 다르기 때문에, 메모리 주소 관련 처리를 추가적으로 수행해야 합니다.
- 그래서 MMU(Memory Manage Unit) 또한 새로운 프로세스의 주소 체계를 바로보도록 수정해줘야 하고, TLB(Translation Lookaside Buffer)라는 가상 메모리 주소와 실제 메모리 주소의 매핑 정보를 들고 있는 캐시도 비워줘야 합니다.
- 만약 TLB 캐시를 비워주지 않는 경우 이전에 작업했던 프로세스의 주소에 접근할 가능성이 있기 때문에 반드시 수행해야 합니다.

---

## 스레드 컨텍스트 스위칭이 프로세스보다 빠른 이유
- 스레드 컨텍스트 스위칭(Thread Context Switching)의 경우 프로세스 컨텍스트 스위칭(Process Context Switching)과 달리 MMU 새로운 주소 체계 바로보도록 수정하고 TLB 가상 메모리, 실제 메모리 저장된 캐시를 비우는 등의 메모리 주소 관련 작업을 하지 않고, CPU의 상태 정보만 바꿔주면 되기 때문입니다.

---



---

<br>

> ## 내용이 좀 어려워서 추가 학습 진행

<br>

---

출처 : https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4

## 완전히 정복하는 프로세스 vs 스레드 개념


---

# **프로세스와 스레드**

## **1. 프로세스와 스레드의 정의**

| **항목**         | **프로세스**                                     | **스레드**                                     |
|------------------|--------------------------------------------------|-----------------------------------------------|
| **정의**         | 실행 중인 프로그램. 독립적으로 실행되는 작업 단위.  | 프로세스 내에서 실행되는 흐름의 단위.           |
| **메모리 구조**  | 독립적인 메모리 공간을 사용.                     | 프로세스 내에서 메모리를 공유.                 |
| **안정성**       | 프로세스 간 독립성이 높아 충돌 가능성이 낮음.       | 자원 공유로 인해 동기화 문제가 발생 가능.       |
| **효율성**       | 프로세스 간 통신 비용이 높음.                     | 스레드 간 통신이 상대적으로 저렴함.             |
| **오버헤드**     | 컨텍스트 스위칭 시 더 높은 오버헤드 발생.          | 컨텍스트 스위칭 시 오버헤드가 적음.             |

**추가 설명**:
- **프로세스**는 운영체제로부터 자원을 할당받아 실행되는 작업 단위입니다. 
- **스레드**는 프로세스 내의 실행 흐름으로, 프로세스가 할당받은 자원을 공유하여 작업을 수행합니다.

---

## **2. 프로그램과 프로세스의 차이**

| **항목**         | **프로그램**                                | **프로세스**                                |
|------------------|--------------------------------------------|--------------------------------------------|
| **정의**         | 저장 장치에 저장된 실행 가능한 정적 코드.      | 실행 중인 프로그램으로, 자원을 할당받아 동작함. |
| **특징**         | 실행되지 않는 정적인 상태.                   | 실행되어 CPU를 사용하는 동적인 상태.          |

**추가 설명**:
- 프로그램은 **잠재적 실행 가능성**만 가진 상태이고, 프로세스는 실행되고 있는 **실제 작업 단위**입니다.

---

## **3. 프로세스 메모리 구조**

| **메모리 영역**   | **설명**                                                                 |
|-------------------|-------------------------------------------------------------------------|
| **코드(Code)**    | 프로그램의 코드가 저장되는 영역 (함수, 명령어 등).                           |
| **데이터(Data)**  | 전역 변수와 정적 변수가 저장되는 영역. 초기화된 데이터(.data), 초기화되지 않은 데이터(.bss), 상수(.rodata)로 나뉨. |
| **스택(Stack)**   | 함수 호출 시 지역 변수와 반환 주소 등이 저장되는 영역. 함수 종료 시 제거됨.        |
| **힙(Heap)**      | 동적으로 할당된 메모리가 저장되는 영역. 프로그래머가 직접 관리해야 함.              |

### **시각적 구조:**
```
프로세스 메모리 구조
┌──────────────┐
│  코드 영역   │
├──────────────┤
│  데이터 영역 │
├──────────────┤
│  힙 영역     │
├──────────────┤
│  스택 영역   │
└──────────────┘
```

---

## **4. 스레드 메모리 구조**

### **스레드 내 메모리 공유**
- **공유되는 영역**: 코드, 데이터, 힙.
- **개별 스택**: 각 스레드는 자신만의 스택 영역을 가짐.

### **시각적 구조:**
```
프로세스
├── 코드 영역 (공유)
├── 데이터 영역 (공유)
├── 힙 영역 (공유)
└── 스레드 1
    └── 스택
└── 스레드 2
    └── 스택
```

---

## **5. 멀티 프로세스와 멀티 스레드**

| **항목**         | **멀티 프로세스**                               | **멀티 스레드**                               |
|------------------|-----------------------------------------------|----------------------------------------------|
| **정의**         | 여러 프로세스를 동시에 실행.                     | 하나의 프로세스 내에서 여러 스레드를 실행.       |
| **장점**         | 안정성 높음 (각 프로세스 독립적).                | 메모리 효율성 및 빠른 통신 가능.                |
| **단점**         | 프로세스 간 통신 복잡, 자원 소모 큼.             | 동기화 문제 발생 가능.                         |

---

## **6. 컨텍스트 스위칭 (Context Switching)**

| **항목**          | **설명**                                                     |
|-------------------|------------------------------------------------------------|
| **정의**          | CPU가 현재 실행 중인 프로세스/스레드의 상태를 저장하고, 다른 프로세스/스레드로 전환. |
| **프로세스**       | 높은 오버헤드 발생 (독립적 메모리 관리로 캐시 무효화 등).          |
| **스레드**         | 낮은 오버헤드 발생 (메모리 공유로 상태 저장 간소화).             |

---

## **7. 스레드 상태**

| **상태**          | **설명**                                                       |
|-------------------|-------------------------------------------------------------|
| **NEW**          | 스레드가 생성되었지만 아직 실행되지 않은 상태.                      |
| **RUNNABLE**     | 실행 대기 상태, CPU 할당 가능.                                    |
| **BLOCKED**      | 특정 이벤트(입출력 등)로 인해 대기 중인 상태.                      |
| **TERMINATED**   | 실행 완료 후 종료된 상태.                                        |

**상태 전이 흐름도**:
```
NEW → RUNNABLE ↔ RUNNING ↔ BLOCKED → TERMINATED
```

---

## **8. 정리된 요점**
- **프로세스**는 독립적이며 실행 중인 프로그램으로, 자원 소모가 크지만 안정성이 높습니다.
- **스레드**는 프로세스 내 실행 흐름 단위로, 메모리를 공유하여 효율적이지만 동기화 문제가 발생할 수 있습니다.
- **컨텍스트 스위칭**은 프로세스에서 더 큰 오버헤드를 유발하며, 스레드에서는 상대적으로 적은 비용이 듭니다.
- **멀티 스레드**는 효율적인 메모리 사용과 빠른 통신을 가능하게 하지만, 동기화 문제가 복잡성을 증가시킵니다.

---

위 내용은 첫 번째와 두 번째 답변의 모든 정보를 통합하여, 설명과 시각적인 표현을 조화롭게 구성한 최종 정리본입니다. 필요한 추가 사항이 있다면 알려주세요!
