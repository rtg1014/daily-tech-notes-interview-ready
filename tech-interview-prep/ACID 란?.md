## ACID
- ACID 는 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)의 약자이며, 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 의미합니다.


## 각 속성이 의미하는것은? 

예시)
1. A 계좌에 3000원 출금
2. B 계좌에 3000원 입금


---


## 원자성(Atomicity)
- 원자성(Atomicity) 은 트랜잭션 내부 연산들이 부분적으로 실행되고 중단되지 않는 것을 보장합니다. 쉽게 말하자면, 트랜잭션은 전체 성공과 전체 실패 중 한 가지만 수행한다는 것입니다.
- 예를 들면 계좌 이체 트랜잭션은 다음과 같은 연산으로 이루어져 있습니다.
- 이때 2번 과정에서 에러가 발생하면 1번 과정을 취소해야 합니다.



---

<br>

  


## 일관성(Consistency) 
- 일관성(Consistency) 은 트랜잭션이 성공적으로 완료되면 일관성 있는 데이터베이스 상태로 유지되는 것을 보장합니다.
- 가령, 제약조건과 같이 데이터베이스에 정의된 규칙을 트랜잭션이 위반하는 경우에는 해당 트랜잭션은 취소되어야 합니다.



---

<br>

  

## 격리성(Isolation) 
- 격리성(Isolation) 은 동시에 실행되는 여러 트랜잭션이 서로 독립적임을 보장합니다. 가장 엄격할 경우에는 트랜잭션을 순차적으로 실행하기도 합니다.
- 트랜잭션을 수행할 때 다른 트랜잭션이 해당 작업 사이에 끼어들지 못하도록 보장합니다.
- 쉽게 이야기하자면 트랜잭션 밖에서 어떠한 연산도 중간 단계의 데이터를 볼 수 없음을 의미합니다. 가령, 계좌 이체 작업에서 A 계좌의 잔고와 B 계좌의 잔고 총합이 10,000원인 상태로 시작했을 때, 특정 순간에는 총합이 10,000원이 아닌 경우도 있을 것입니다. 하지만, 다른 트랜잭션은 항상 잔고의 총합인 10,000원을 볼 수 있도록 보장되어야 합니다.

---

<br>

## 지속성(Durability) 
- 지속성(Durability) 은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 보장합니다.
- 시스템에 장애가 발생해도 성공적으로 수행된 트랜잭션의 결과는 항상 데이터베이스에 반영되어 있어야 합니다.
- 전형적으로 트랜잭션은 로그로 남고, 로그가 저장되어야 트랜잭션이 성공되었다고 간주합니다. 추후 장애가 발생한다면 이 로그를 활용해 데이터베이스를 회복합니다.



---
---


## 추가학습자료

### [10분 테코톡] 로건의 Transaction
원문 : https://www.youtube.com/watch?v=taUeIi6a6hk

### **트랜잭션 발표 요약**

#### **1. 트랜잭션이란?**
- **정의**: 여러 작업(쿼리)을 하나의 논리적 단위로 묶어 수행하는 것.
  - 이전 기수들의 정의내용
  - 예지니어스: "여러 쿼리를 논리적 하나의 작업 단위로 묶는 것"
  - 샐리: "더 이상 나눌 수 없는 가장 작은 작업 단위"
  - 로건: "데이터베이스에서 여러 작업을 하나의 논리적 단위로 수행하는 것"

- **공통 키워드**: **하나의 작업 단위**
- **예시**: A가 B에게 10만 원 송금
  - 1단계: A의 계좌에서 10만 원 출금 (DB 업데이트 → 10만 원 → 0원)
  - 2단계: B의 계좌에 10만 원 입금 (DB 업데이트 → 0원 → 10만 원)
  - 트랜잭션 선언 → 두 작업을 하나의 작업으로 묶음.
  - **결과**:
    - 성공: `커밋` (DB에 반영)
    - 실패: `롤백` (처음 상태로 되돌림)

---

#### **2. 트랜잭션의 ACID 특성**
- **ACID**: 트랜잭션이 안전하게 수행되도록 보장하는 성질.
  1. **원자성 (Atomicity)**: "All or Nothing" → 모든 작업이 수행되거나 전혀 수행되지 않아야 함.
  2. **일관성 (Consistency)**: 데이터베이스가 무결성 제약 조건을 항상 만족해야 함.
  3. **고립성 (Isolation)**: 한 트랜잭션은 다른 트랜잭션의 영향을 받거나 주지 않음.
  4. **지속성 (Durability)**: 성공적으로 수행된 트랜잭션 결과는 영구적으로 DB에 반영.

---

### **3. 트랜잭션의 고립 수준 (Isolation Levels)**  


#### **READ-UNCOMMITTED**
- **특징**: 
  - 아직 커밋되지 않은 데이터를 읽을 수 있음.
  - 예시:
    1. A 계좌에 10만 원이 있음.
    2. 트랜잭션 A가 10만 원을 15만 원으로 변경하지만 아직 커밋하지 않음.
    3. 트랜잭션 B가 데이터를 읽으면 15만 원을 반환받음.
    4. 만약 트랜잭션 A에서 오류가 발생해 롤백된다면, DB 값은 다시 10만 원으로 돌아가지만, 트랜잭션 B는 잘못된 값(15만 원)을 반환받아 문제가 발생.
- **문제점**:
  - **Dirty Read**: 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 문제.
  - **Non-Repeatable Read**: 같은 데이터를 조회했는데 값이 달라지는 문제.
  - **Phantom Read**: 데이터 삽입/삭제로 인해 결과 집합이 달라지는 문제.

---

#### **READ-COMMITTED**
- **특징**:
  - 커밋된 데이터만 읽을 수 있음.
  - 예시:
    1. A 계좌에 10만 원이 있음.
    2. 트랜잭션 A가 데이터를 읽으면 10만 원을 반환받음.
    3. 트랜잭션 A가 5만 원을 입금해 DB에 15만 원이 됨.
    4. 트랜잭션 B가 읽기 연산을 수행하면 10만 원(트랜잭션 A의 커밋 전 값)을 반환.
    5. 트랜잭션 A가 커밋한 이후, 트랜잭션 B가 다시 읽으면 15만 원이 반환됨.
- **해결**:
  - **Dirty Read 문제 해결**: 커밋된 데이터만 읽기 때문에 롤백된 데이터를 반환받지 않음.
- **문제점**:
  - **Non-Repeatable Read**: 동일한 데이터를 반복 조회 시 값이 달라질 수 있음.
  - **Phantom Read**: 데이터 삽입/삭제로 인해 결과가 변할 수 있음.

---

#### **REPEATABLE-READ**
- **특징**:
  - 특정 데이터를 반복 조회 시 항상 같은 값을 반환.
  - 예시:
    1. 트랜잭션 A가 계좌의 데이터를 조회했을 때 10만 원을 반환받음.
    2. 트랜잭션 A가 커밋 전까지는 트랜잭션 B가 데이터를 변경하지 못함.
    3. 트랜잭션 A는 동일 데이터를 조회해도 항상 같은 값(10만 원)을 반환받음.
- **해결**:
  - **Non-Repeatable Read 문제 해결**: 동일 데이터를 여러 번 조회해도 결과가 일치함.
- **문제점**:
  - **Phantom Read**: 데이터 삽입/삭제가 발생하면 쿼리 결과 집합이 달라질 수 있음.
    - 예: 트랜잭션 B가 새로운 계좌를 추가하면, 트랜잭션 A가 다시 조회할 때 반환받는 계좌 수가 달라지는 문제.

---

#### **SERIALIZABLE**
- **특징**:
  - 트랜잭션을 순차적으로 실행하여 고립성을 완벽히 보장.
  - 모든 작업이 직렬화된 순서로 실행되어 데이터 간섭이 전혀 없음.
  - 예시:
    1. 트랜잭션 A가 10만 원 데이터를 읽고 5만 원을 입금한 후 커밋.
    2. 트랜잭션 B는 트랜잭션 A의 작업이 끝난 후에야 데이터를 읽고 15만 원을 반환받음.
- **해결**:
  - **Dirty Read**, **Non-Repeatable Read**, **Phantom Read** 모든 문제를 해결.
- **문제점**:
  - 순차적으로 트랜잭션을 처리하므로 병렬 처리 불가능 → 성능 저하.

---

### **4. 고립 수준 요약**
- **READ-UNCOMMITTED**: Dirty Read, Non-Repeatable Read, Phantom Read 문제 발생.
- **READ-COMMITTED**: Dirty Read 해결. Non-Repeatable Read, Phantom Read 문제 발생.
- **REPEATABLE-READ**: Non-Repeatable Read 문제 해결. Phantom Read 문제 발생.
- **SERIALIZABLE**: 모든 문제 해결. 하지만 속도 느림.
- 

<br>

---
---

<br>


## 추가적으로 이해가 안되는 부분들 부분학습한 내용



> ## 첫번째 의문

```

**" 이전에는 트랜잭션이란 결국 무결성을 보장하기 위해 사용하는 롤백 시스템인 줄 알았는데 세부적으로 보니 기존에 알고 있던것들과는 조금 달랐다.
과연 실제로 개발자가 직접 커밋을 열고 닫는 작업을 하는 경우가 얼마나 있을까?"** 


그 이전에 디비를 조작할때에 어지간해선 커밋을 시작하고 닫는 행위자체가 많지는 않았던것 같았다.
기껏해야 디비에서 테이블 조작중 관계설정된 데이터들을 연쇄적으로 삭제하고 해당하는 두개 이상의 테이블들에 대해서 조작이 필요하거나 하는경우 외에는
특별하게 사용했던 이력이 없었던 것 같다.


그래서 해당 내용에 대해서 의문적이 생기고 추가적이 학습을 진행했다.

```



---

### **1. 트랜잭션 = 롤백이라는 이해**
- **트랜잭션의 핵심은 데이터 무결성과 일관성을 보장하는 것**입니다. 
  - "트랜잭션 = 롤백"이라는 개념이 완전히 틀린 것은 아닙니다. 트랜잭션이 실패했을 때 상태를 복구(롤백)하여 데이터 무결성을 유지하기 때문입니다.
  - 하지만, 트랜잭션은 성공 시 **커밋**이라는 연산도 포함됩니다. 즉, 트랜잭션은 **작업의 묶음을 원자적으로 처리**하는 것이 목표입니다.
  - **스프링의 `@Transactional`**:
    - 이 어노테이션은 기본적으로 트랜잭션의 "시작"과 "종료(커밋/롤백)"를 자동으로 관리합니다.
    - 예를 들어, `@Transactional`이 붙어 있는 메서드 내에서 예외가 발생하면 자동으로 롤백됩니다. 따라서 개발자는 직접 트랜잭션을 열고 닫는 작업을 하지 않아도 됩니다.
    - 이는 개발자의 부담을 줄이고 생산성을 높이는 역할을 합니다.

---

### **2. 실제로 트랜잭션을 직접 열고 닫는 경우가 있을까?**
스프링에서 대부분은 `@Transactional` 같은 어노테이션으로 트랜잭션을 처리하지만, 다음과 같은 경우에는 직접 트랜잭션을 관리할 필요가 있을 수 있습니다:

#### 1) **복잡한 트랜잭션 제어가 필요한 경우**
- 예: 여러 단계의 작업 중 특정 조건에서만 커밋 또는 롤백을 해야 하는 경우.
- **예시**:
  ```java
  TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
  try {
      // Step 1: 작업 1 수행
      someRepository.save(entity1);

      // Step 2: 작업 2 수행
      someRepository.save(entity2);

      // Step 3: 특정 조건에서 커밋
      if (condition) {
          transactionManager.commit(status);
      } else {
          transactionManager.rollback(status);
      }
  } catch (Exception e) {
      transactionManager.rollback(status);
      throw e;
  }
  ```

#### 2) **JDBC 직접 사용**
- JPA나 ORM을 사용하지 않고, JDBC를 사용해 SQL 쿼리를 직접 작성하고 실행하는 경우.
- **예시**:
  ```java
  Connection connection = dataSource.getConnection();
  try {
      connection.setAutoCommit(false); // 트랜잭션 시작

      // 쿼리 실행
      Statement stmt = connection.createStatement();
      stmt.executeUpdate("UPDATE account SET balance = balance - 100 WHERE id = 1");
      stmt.executeUpdate("UPDATE account SET balance = balance + 100 WHERE id = 2");

      connection.commit(); // 성공 시 커밋
  } catch (SQLException e) {
      connection.rollback(); // 실패 시 롤백
  } finally {
      connection.close();
  }
  ```

#### 3) **배치 작업**
- 데이터베이스에 대량의 데이터를 삽입하거나 업데이트하는 경우, 효율성을 위해 직접 트랜잭션을 제어할 수 있습니다.
- **예시**: 매 1000건씩 데이터를 처리 후 커밋.

#### 4) **여러 데이터베이스를 동시에 다루는 경우 (Distributed Transaction)**
- 두 개 이상의 데이터베이스에서 데이터를 동시에 조작해야 하는 경우, 개발자가 직접 트랜잭션을 제어하거나, **JTA(Java Transaction API)** 같은 분산 트랜잭션 매니저를 사용합니다.

#### 5) **특정 트랜잭션 설정을 커스터마이징해야 하는 경우**
- 예: 특정 트랜잭션에서만 **읽기 전용**, 특정 고립 수준 설정, 타임아웃 설정이 필요한 경우.
- **예시**:
  ```java
  @Transactional(readOnly = true, isolation = Isolation.READ_COMMITTED, timeout = 10)
  public List<User> findAllUsers() {
      return userRepository.findAll();
  }
  ```

---

### **3. 실생활에서 실제 사용 사례**
**대부분의 애플리케이션에서 트랜잭션은 프레임워크가 자동으로 관리**합니다. 하지만 다음과 같은 경우 직접 트랜잭션을 제어할 수 있습니다:

#### **1) 금융 시스템**
- 은행 송금, 결제 처리 등에서는 데이터 무결성이 매우 중요.
- 예: 한 계좌에서 돈을 인출하고 다른 계좌로 입금하는 작업이 동시에 이루어져야 함.
- 만약 일부 작업이 실패하면 전체 작업을 롤백해야 함.

#### **2) 전자상거래 시스템**
- 주문 생성, 재고 감소, 결제 처리 등 여러 단계로 이루어진 작업.
- 모든 작업이 성공해야 최종적으로 주문이 완료됨.

#### **3) 배치 처리**
- 백엔드에서 대량의 데이터를 처리하는 작업.
- 작업 중 일부가 실패하면 전체 트랜잭션을 롤백하거나, 처리된 데이터만 커밋할 수 있음.

#### **4) 데이터 마이그레이션**
- 기존 시스템에서 데이터를 새로운 시스템으로 옮길 때, 데이터 무결성을 유지하기 위해 트랜잭션을 직접 관리.

---

### **4. 결론**
- 일반적인 애플리케이션 개발에서는 스프링의 `@Transactional`로 트랜잭션을 처리하므로 직접 트랜잭션을 열고 닫는 경우는 드뭅니다.
- 하지만 **복잡한 트랜잭션 제어, 대규모 배치 작업, 또는 여러 DB를 다루는 분산 트랜잭션**에서는 개발자가 트랜잭션을 직접 관리해야 할 수 있습니다.
- 따라서 **"직접 트랜잭션을 열고 닫을 일이 거의 없다"**라는 사용자의 경험은 일반적이고, 대부분의 상황에서 프레임워크가 이를 대신 처리합니다.

궁금한 부분이나 추가로 설명이 필요한 사례가 있다면 말씀해주세요!



<br>

---
---

<br>


> ## 두번째 의문들

주제의 핵심은 **트랜잭션 고립 수준의 필요성**, **실제 사용 사례에서의 의문**, 그리고 **고립 수준 단계의 존재 이유** 이다.



### **1. SERIALIZABLE 말고는 전부 안정적이지 못한 것 아닌가?**
- **SERIALIZABLE이 가장 안정적인 것은 맞습니다.**
  - SERIALIZABLE은 모든 트랜잭션을 순차적으로 실행하기 때문에 데이터 무결성과 일관성이 완벽히 보장됩니다.
    

- **하지만 현실적으로 성능과 효율성을 위해 다른 고립 수준이 필요합니다.**
  - SERIALIZABLE은 트랜잭션을 병렬로 처리하지 못하므로, 대규모 데이터베이스 시스템에서는 속도와 처리량 측면에서 한계가 있습니다.
  - 예를 들어, 대형 쇼핑몰에서 모든 사용자의 결제 트랜잭션을 SERIALIZABLE로 처리하면, 병목 현상이 발생하고 서비스 속도가 느려집니다.
  - 따라서 **데이터 무결성의 중요도와 시스템 성능의 균형**을 맞추기 위해 다른 고립 수준이 존재합니다.


---

### **2. SERIALIZABLE 외에 다른 고립 수준이 필요한 이유가 있나요?**
- **다른 고립 수준은 성능과 데이터 무결성의 균형을 맞추기 위한 것입니다.**
  - **READ-COMMITTED, REPEATABLE-READ**와 같은 고립 수준은 특정 문제를 해결하면서도 SERIALIZABLE보다 더 나은 성능을 제공합니다.
  - 모든 상황에서 데이터 무결성이 절대적으로 필요하지 않은 경우도 많습니다.
    - 예: 로그 기록, 통계 조회, 읽기 전용 작업 등.
  - 이러한 작업에서는 SERIALIZABLE처럼 모든 트랜잭션을 순차적으로 처리하지 않아도 충분히 안전합니다.

- **예시:**
  - **전자 상거래 사이트의 상품 조회**:
    - 사용자가 상품을 조회할 때, 최신 데이터가 완벽히 보장되지 않아도 큰 문제가 없습니다.
    - READ-COMMITTED 수준만으로도 Dirty Read를 방지하며 충분한 일관성을 제공합니다.

---

### **3. 왜 고립 수준 단계가 존재하나요? 저 3가지는 잘못된 사용 방식 아닌가요?**
- **고립 수준은 잘못된 사용 방식이 아니라 데이터 무결성과 성능 간의 타협입니다.**
  - 모든 트랜잭션을 SERIALIZABLE로 처리하면 이상적이겠지만, 이는 현실적으로 불가능합니다.
  - 데이터 무결성이 필요하지 않은 작업에서는 성능이 더 중요하기 때문에 낮은 고립 수준이 유용합니다.

- **각 고립 수준이 존재하는 이유:**
  - **READ-UNCOMMITTED**:
    - 가장 빠르지만 데이터 무결성 보장이 필요 없는 상황에서 사용.
    - 예: 로그 데이터, 통계 수집 등.
  - **READ-COMMITTED**:
    - Dirty Read 문제를 해결하면서도 성능을 적절히 유지.
    - 예: 사용자 조회, 상품 리스트 조회 등.
  - **REPEATABLE-READ**:
    - 동일 데이터를 여러 번 조회해야 하는 상황에서 Non-Repeatable Read 문제를 방지.
    - 예: 은행 계좌의 잔액을 조회하고 수정하는 경우.
  - **SERIALIZABLE**:
    - 데이터 일관성이 최우선인 작업에서 사용.
    - 예: 결제 시스템, 금융 거래 등.

---

### **4. 정리 **
- **SERIALIZABLE은 안정적이지만 성능 문제로 모든 상황에 적합하지 않습니다.**
- 다른 고립 수준은 데이터 무결성의 필요 정도와 성능을 조율하기 위해 존재합니다.
- 트랜잭션의 고립 수준은 **데이터 손상의 위험과 성능의 균형**을 맞추기 위한 설계 철학에 기반합니다.
- **스프링의 @Transactional 어노테이션을 사용하는 경우에도, 내부적으로 고립 수준을 설정하여 이러한 문제를 해결하고 있습니다.**

---


