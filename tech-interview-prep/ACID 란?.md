## ACID
- ACID 는 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)의 약자이며, 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 의미합니다.


## 각 속성이 의미하는것은? 

예시)
1. A 계좌에 3000원 출금
2. B 계좌에 3000원 입금


---


## 원자성(Atomicity)
- 원자성(Atomicity) 은 트랜잭션 내부 연산들이 부분적으로 실행되고 중단되지 않는 것을 보장합니다. 쉽게 말하자면, 트랜잭션은 전체 성공과 전체 실패 중 한 가지만 수행한다는 것입니다.
- 예를 들면 계좌 이체 트랜잭션은 다음과 같은 연산으로 이루어져 있습니다.
- 이때 2번 과정에서 에러가 발생하면 1번 과정을 취소해야 합니다.



---

<br>

  


## 일관성(Consistency) 
- 일관성(Consistency) 은 트랜잭션이 성공적으로 완료되면 일관성 있는 데이터베이스 상태로 유지되는 것을 보장합니다.
- 가령, 제약조건과 같이 데이터베이스에 정의된 규칙을 트랜잭션이 위반하는 경우에는 해당 트랜잭션은 취소되어야 합니다.



---

<br>

  

## 격리성(Isolation) 
- 격리성(Isolation) 은 동시에 실행되는 여러 트랜잭션이 서로 독립적임을 보장합니다. 가장 엄격할 경우에는 트랜잭션을 순차적으로 실행하기도 합니다.
- 트랜잭션을 수행할 때 다른 트랜잭션이 해당 작업 사이에 끼어들지 못하도록 보장합니다.
- 쉽게 이야기하자면 트랜잭션 밖에서 어떠한 연산도 중간 단계의 데이터를 볼 수 없음을 의미합니다. 가령, 계좌 이체 작업에서 A 계좌의 잔고와 B 계좌의 잔고 총합이 10,000원인 상태로 시작했을 때, 특정 순간에는 총합이 10,000원이 아닌 경우도 있을 것입니다. 하지만, 다른 트랜잭션은 항상 잔고의 총합인 10,000원을 볼 수 있도록 보장되어야 합니다.

---

<br>

## 지속성(Durability) 
- 지속성(Durability) 은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 보장합니다.
- 시스템에 장애가 발생해도 성공적으로 수행된 트랜잭션의 결과는 항상 데이터베이스에 반영되어 있어야 합니다.
- 전형적으로 트랜잭션은 로그로 남고, 로그가 저장되어야 트랜잭션이 성공되었다고 간주합니다. 추후 장애가 발생한다면 이 로그를 활용해 데이터베이스를 회복합니다.



---
---


## 추가학습자료

### [10분 테코톡] 로건의 Transaction
원문 : https://www.youtube.com/watch?v=taUeIi6a6hk

### **트랜잭션 발표 요약**

#### **1. 트랜잭션이란?**
- **정의**: 여러 작업(쿼리)을 하나의 논리적 단위로 묶어 수행하는 것.
  - 이전 기수들의 정의내용
  - 예지니어스: "여러 쿼리를 논리적 하나의 작업 단위로 묶는 것"
  - 샐리: "더 이상 나눌 수 없는 가장 작은 작업 단위"
  - 로건: "데이터베이스에서 여러 작업을 하나의 논리적 단위로 수행하는 것"

- **공통 키워드**: **하나의 작업 단위**
- **예시**: A가 B에게 10만 원 송금
  - 1단계: A의 계좌에서 10만 원 출금 (DB 업데이트 → 10만 원 → 0원)
  - 2단계: B의 계좌에 10만 원 입금 (DB 업데이트 → 0원 → 10만 원)
  - 트랜잭션 선언 → 두 작업을 하나의 작업으로 묶음.
  - **결과**:
    - 성공: `커밋` (DB에 반영)
    - 실패: `롤백` (처음 상태로 되돌림)

---

#### **2. 트랜잭션의 ACID 특성**
- **ACID**: 트랜잭션이 안전하게 수행되도록 보장하는 성질.
  1. **원자성 (Atomicity)**: "All or Nothing" → 모든 작업이 수행되거나 전혀 수행되지 않아야 함.
  2. **일관성 (Consistency)**: 데이터베이스가 무결성 제약 조건을 항상 만족해야 함.
  3. **고립성 (Isolation)**: 한 트랜잭션은 다른 트랜잭션의 영향을 받거나 주지 않음.
  4. **지속성 (Durability)**: 성공적으로 수행된 트랜잭션 결과는 영구적으로 DB에 반영.

---

#### **3. 트랜잭션의 고립 수준 (Isolation Levels)**
- **고립성과 성능의 균형**:
  - 낮은 수준 → 빠르지만 데이터 일관성 저하 가능.
  - 높은 수준 → 느리지만 데이터 일관성 보장.

1. **READ-UNCOMMITTED**
   - **특징**: 커밋되지 않은 데이터를 읽을 수 있음.
   - **문제점**:
     - **Dirty Read**: 롤백된 데이터를 읽는 문제.
     - **Non-Repeatable Read**, **Phantom Read** 문제 존재.

2. **READ-COMMITTED**
   - **특징**: 커밋된 데이터만 읽음.
   - **해결**: Dirty Read 문제 해결.
   - **문제점**:
     - **Non-Repeatable Read**: 동일 데이터를 여러 번 조회 시 값이 다를 수 있음.
     - **Phantom Read** 문제 존재.

3. **REPEATABLE-READ**
   - **특징**: 동일 데이터를 반복 조회 시 항상 같은 값을 반환.
   - **해결**: Non-Repeatable Read 문제 해결.
   - **문제점**:
     - **Phantom Read**: 데이터 추가/삭제로 인해 상반된 결과 발생.

4. **SERIALIZABLE**
   - **특징**: 트랜잭션을 순차적으로 실행 → 고립성을 완벽히 보장.
   - **장점**: 모든 문제(DR, NR, PR) 해결.
   - **단점**: 성능 저하.

---

#### **4. 고립 수준 요약**
- **READ-UNCOMMITTED**: Dirty Read, Non-Repeatable Read, Phantom Read 문제 발생.
- **READ-COMMITTED**: Dirty Read 해결. Non-Repeatable Read, Phantom Read 문제 존재.
- **REPEATABLE-READ**: Non-Repeatable Read 해결. Phantom Read 문제 존재.
- **SERIALIZABLE**: 모든 문제 해결. 성능 저하.

---

#### **마무리**
- 트랜잭션은 데이터 일관성과 무결성을 보장하기 위해 사용됨.
- 현실적인 성능 타협을 위해 고립 수준을 선택해야 함.
- SERIALIZABLE은 신중히 사용.
