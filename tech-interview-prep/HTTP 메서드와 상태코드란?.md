
[10분 테코톡] 코카콜라의 HTTP 메서드와 상태코드
출처 : https://www.youtube.com/watch?v=QcKEJFvPryI

### 🚀 **HTTP 메서드와 상태코드 완벽 가이드**  

---

## **📌 1. HTTP란?**  

✔ **HyperText Transfer Protocol** → 웹에서 **클라이언트(브라우저)와 서버 간 데이터 전송**  
✔ **요청(Request)과 응답(Response) 방식**으로 동작  
✔ **Stateless (무상태성)** → 요청 간 **상태 정보 저장 X**  

---

## **📌 2. HTTP 요청과 응답의 흐름**  

✔ 클라이언트(브라우저) → **요청(Request)** → 서버  
✔ 서버 → **응답(Response)** → 클라이언트  

> **📌 요청 구조**  
✅ **HTTP 메서드** (GET, POST 등)  
✅ **Request URL** (요청 주소)  
✅ **Header** (요청 정보)  
✅ **Body** (POST, PUT 등에서 사용)  

> **📌 응답 구조**  
✅ **Status Code (상태 코드)**  
✅ **Header** (응답 정보)  
✅ **Body** (JSON, HTML, 이미지 등)  

---

## **📌 3. HTTP 메서드 - 리소스를 어떻게 가져올까?**  

✔ **리소스(데이터) 요청 & 수정 방식** 결정  
✔ 주요 HTTP 메서드:

| 메서드 | 설명 | 사용 예시 |
|---|---|---|
| **GET** | 리소스 조회 | `GET /users` |
| **POST** | 리소스 생성 | `POST /users` |
| **PUT** | 리소스 전체 수정 | `PUT /users/1` |
| **PATCH** | 리소스 부분 수정 | `PATCH /users/1` |
| **DELETE** | 리소스 삭제 | `DELETE /users/1` |

---

## **📌 4. 웹 브라우저에서 HTTP 요청 확인하기**  

🎯 **크롬 개발자 도구 (F12) → Network 탭** 활용  

1️⃣ **배달의 민족 사이트 검색**  
2️⃣ **리소스 요청 목록 확인**  
3️⃣ **Request URL & HTTP 메서드**  
4️⃣ **응답(Response) 내용 분석**  

✔ 예제: `GET /api/data` 요청 시  
✅ **응답 코드 200** (정상 응답)  
✅ **Content-Type: application/json**  
✅ **Response Body** → JSON 데이터  

---

## **📌 5. HTTP 상태코드 - 응답의 의미**  

✔ 서버가 클라이언트 요청을 어떻게 처리했는지 알려줌  

| 상태코드 | 의미 | 설명 |
|---|---|---|
| **2xx (성공)** | 요청 정상 처리됨 | 200(OK), 201(Created) |
| **3xx (리다이렉션)** | 추가 작업 필요 | 301(영구 이동), 304(캐시 사용) |
| **4xx (클라이언트 오류)** | 요청 문제 발생 | 400(잘못된 요청), 404(리소스 없음) |
| **5xx (서버 오류)** | 서버 문제 발생 | 500(내부 서버 오류), 503(서비스 불가) |

---

## **📌 6. 304 상태코드 - 캐시와 성능 최적화**  

🎯 **웹 브라우저에서 304 응답 확인하기!**  

✔ **304 Not Modified (변경 없음)**  
✔ 같은 리소스를 **새로 다운로드하지 않고 캐시에서 사용**  
✔ 성능 최적화 & 네트워크 부하 감소  

> **📌 304가 동작하는 원리**  
✅ 브라우저가 `ETag` 값을 요청 헤더(`If-None-Match`)에 포함  
✅ 서버는 `ETag` 값을 비교  
✅ **같으면 304 응답 (캐시 사용) / 다르면 200 응답 (새로운 리소스 전송)**  

---

## **📌 7. HTTP 메서드 & 상태코드 정리**  

✔ **HTTP는 클라이언트 & 서버 간 요청/응답을 처리하는 프로토콜**  
✔ **GET, POST, PUT, PATCH, DELETE 등 다양한 메서드 존재**  
✔ **응답 상태코드 (2xx, 3xx, 4xx, 5xx)로 요청 결과 확인 가능**  
✔ **304 응답을 통해 캐시 최적화 가능**  



---
---

<br>


> ## 상태코드의 사용에 따른 추가로 알아야할 추가학습 정보들


<br>


### **📌 기술면접에서 HTTP 메서드 관련 질문의 의도와 심층적인 답변 정리**  

기술면접에서 `GET`과 `POST`의 차이를 묻는다면 단순히 기초적인 개념을 확인하려는 것이 아니라, **HTTP 프로토콜의 설계 원칙과 각 메서드의 특성을 깊이 있게 이해하고 있는지**를 평가하려는 의도가 있을 가능성이 큽니다.  

단순히 "GET은 조회, POST는 전송"이라고 답변하는 것보다, **캐싱, 멱등성, 보안성, 데이터 전송 방식** 등과 관련된 심도 있는 내용을 포함하여 설명하는 것이 좋습니다.  

---

## **📌 GET vs POST: 단순한 차이 이상의 깊이 있는 설명**
✅ **기본적인 차이**  
| 메서드 | 사용 목적 | 주요 특징 |
|--------|-----------|------------|
| **GET** | 데이터 조회 | 요청 데이터를 URL 파라미터에 포함 (`Query Parameter`) |
| **POST** | 데이터 생성/변경 | 요청 데이터를 `Body`에 담아 전송 |

### **🚀 GET과 POST의 심층적인 차이점**  

| 구분 | **GET** | **POST** |
|----|----|----|
| **멱등성 (Idempotency)** | ✅ 멱등 (같은 요청을 여러 번 보내도 같은 결과) | ❌ 비멱등 (같은 요청을 여러 번 보내면 중복 데이터 생성 가능) |
| **데이터 위치** | URL에 포함 (`Query Parameter`) | HTTP Body에 포함 (`Payload`) |
| **보안성** | 데이터가 URL에 노출되어 **보안 취약 (로그에 남을 가능성, 브라우저 기록 저장)** | Body에 포함되어 상대적으로 **보안성이 높음** (하지만 HTTPS 사용 필수) |
| **캐싱 (Caching)** | ✅ 브라우저 및 CDN 캐싱 가능 | ❌ 기본적으로 캐싱 불가능 (특정 캐시 정책 적용 가능) |
| **데이터 길이 제한** | URL 길이 제한이 있음 (대략 2048자) | Body에 포함되므로 길이 제한이 없음 |
| **사용 사례** | 데이터 조회 (검색, 페이지 이동) | 로그인, 회원가입, 데이터 등록 |

### **🔎 GET도 데이터를 전송할 수 있고, POST도 조회할 수 있는 이유**
> **"GET도 데이터를 전송할 수 있고, POST도 조회에 사용될 수 있다"**  
이는 맞는 말이지만, **실제 API 설계에서 그렇게 사용하면 안 되는 이유**를 아는 것이 중요합니다.  

**1️⃣ GET으로 데이터를 전송하면 안 되는 이유**  
- URL에 포함된 데이터는 **로그, 브라우저 히스토리, 리퍼러 헤더 등에 남아 보안 취약점 발생 가능**  
- **CSRF (Cross-Site Request Forgery) 공격에 취약** → **GET 요청은 브라우저가 자동으로 보낼 가능성이 있어 안전하지 않음**  
- 캐싱이 가능하기 때문에 **예상치 못한 동작이 발생할 수도 있음**  

**2️⃣ POST로 데이터를 조회하면 안 되는 이유**  
- POST는 기본적으로 **비멱등성 (Idempotency X)** 이므로, 동일한 요청을 여러 번 보낼 때 **예상치 못한 부작용이 발생할 가능성이 있음**  
- **캐싱이 되지 않기 때문에 성능 저하 가능** (대량 데이터를 반복 조회하는 API에서 POST를 사용하면 비효율적)  

---

## **📌 PUT vs PATCH: 단순한 차이 이상의 깊이 있는 설명**  

✅ **기본적인 차이**  
| 메서드 | 사용 목적 | 주요 특징 |
|--------|-----------|------------|
| **PUT** | 리소스 전체 업데이트 | 기존 데이터를 **완전히 덮어쓰기 (Full Update)** |
| **PATCH** | 리소스 일부 업데이트 | 필요한 부분만 변경 (Partial Update) |

### **🚀 PUT과 PATCH의 심층적인 차이점**  

| 구분 | **PUT** | **PATCH** |
|----|----|----|
| **멱등성** | ✅ 멱등 (같은 요청을 여러 번 보내도 결과 동일) | ❌ 일반적으로 비멱등 (같은 요청을 여러 번 보내면 다른 결과 발생 가능) |
| **데이터 처리 방식** | 기존 데이터를 **완전히 덮어쓰기** | 일부 필드만 수정 가능 |
| **데이터 누락 가능성** | 일부 필드를 제외하고 요청하면 **누락된 값이 `null`로 저장될 위험** | 변경할 필드만 전송하므로 기존 데이터 유지 가능 |
| **API 설계 방식** | 정적인 리소스를 수정할 때 적합 (ex. 사용자 정보 전체 변경) | 동적인 리소스를 수정할 때 적합 (ex. 일부 필드만 수정) |
| **사용 사례** | **회원 정보 전체 수정 (ex. `PUT /users/1` → 모든 필드 갱신)** | **회원 정보 일부 수정 (ex. `PATCH /users/1` → 닉네임만 변경)** |

### **🔎 PUT을 사용하면 일부 필드가 null로 바뀌는 이유**  
PUT 요청을 할 때 **누락된 필드는 기존 데이터를 덮어써버리기 때문**입니다.  
```json
// 기존 데이터 (DB)
{
  "name": "홍길동",
  "age": 25,
  "email": "test@example.com"
}

// 클라이언트가 PUT 요청 시 보낸 데이터
{
  "name": "이순신"
}

// 결과 (덮어쓰기 때문에 기존 데이터 사라짐)
{
  "name": "이순신",
  "age": null,
  "email": null
}
```
반면 **PATCH는 변경할 필드만 전송 가능**  
```json
// PATCH 요청 (부분 변경)
{
  "name": "이순신"
}

// 결과 (기존 데이터 유지, name만 변경)
{
  "name": "이순신",
  "age": 25,
  "email": "test@example.com"
}
```

---

## **📌 멱등성 (Idempotency)과 안전성 (Safety)의 개념 정리**  

> **멱등성(Idempotency)**: 동일한 요청을 여러 번 보내도 결과가 변하지 않는 성질  
> **안전성(Safety)**: 요청을 여러 번 보내도 서버의 상태가 변하지 않는 성질  

| 메서드 | **멱등성 (Idempotency)** | **안전성 (Safety)** |
|--------|-----------------|-----------------|
| **GET** | ✅ 멱등 | ✅ 안전 |
| **POST** | ❌ 비멱등 | ❌ 비안전 |
| **PUT** | ✅ 멱등 | ❌ 비안전 |
| **PATCH** | ❌ 비멱등 | ❌ 비안전 |
| **DELETE** | ✅ 멱등 | ❌ 비안전 |

**✔ 멱등성과 안전성의 차이**  
- `GET`은 여러 번 보내도 **서버의 상태를 변경하지 않기 때문에 안전(Safe)하고, 응답이 동일하기 때문에 멱등(Idempotent)**  
- `POST`는 **새로운 리소스를 생성하기 때문에 멱등하지 않음 (같은 요청을 반복하면 중복 생성됨)**  
- `PUT`은 **전체 리소스를 덮어쓰기 때문에 멱등하지만, 기존 데이터를 바꿀 수 있어 안전하지 않음**  
- `PATCH`는 **일부 필드만 변경할 수 있어 멱등하지 않고 안전하지 않음**  
- `DELETE`는 **여러 번 호출해도 같은 결과가 나오지만, 서버 상태가 변할 수 있으므로 안전하지 않음**  

---

## **📌 마무리 - 기술면접에서 답변할 때 강조할 점**  

💡 단순한 개념만이 아니라, **HTTP의 설계 원칙과 실제 사용 사례, 보안 이슈, 성능 최적화까지 고려한 답변이 중요**합니다.  
💡 면접관이 추가 질문을 할 경우, **"어떤 문제를 해결하려는 목적이냐"**에 집중하여 답변하면 좋습니다.




<br>

---
---



