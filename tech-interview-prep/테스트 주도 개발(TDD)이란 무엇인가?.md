

## 테스트 주도 개발(Test Driven Development) 
- 테스트 주도 개발(Test Driven Development) 은 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스입니다.
- 개발자는 먼저 요구사항을 검증하는 자동화된 테스트 케이스를 작성합니다.
- 그 이후에는 테스트 케이스를 통과하기 위한 최소한의 코드를 생성하고, 작성한 코드를 리팩토링하는 과정을 반복합니다.

---

테스트 주도 개발 사이클에는 다음과 같이 몇 가지 의식할 부분들이 존재하는데요.

```

- 일단 간단하고, 해보기 쉬운 것을 먼저 시도합니다.
- 실패하는 테스트를 통과하기 위해서는 최소한의 코드를 작성해야 합니다.
- 테스트를 점점 구체화할수록 프로덕션 코드는 점점 범용적으로 됩니다. (커버 가능한 케이스가 점점 많아집니다.)
- 실패하는 테스트가 있을 때만 프로덕션 코드를 작성합니다.
- 실패를 나타내는 데 충분한 정도의 테스트만 작성합니다.

```

- 위와 같은 부분들을 의식하면서, 테스트 주도 개발 사이클을 반복하다 보면, 작성한 코드가 가지는 불안정성을 개선하여 생산성을 높일 수 있습니다.
- 또한, 테스트 가능하며 결합이 느슨한 시스템을 점진적으로 만들어 나갈 수 있습니다.
- 하지만, 테스트 주도 개발이 오히려 비효율적인 경우도 존재하기 때문에 다른 모든 기술과 마찬가지로 비판적으로 사고하는 것도 중요하다고 생각합니다.

<br>

> ## 추가자료

[10분 테코톡] 더즈, 티키의 Classic TDD VS Mockist TDD
출처 : https://www.youtube.com/watch?v=n01foM9tsRo


<br>


### **📌 Classic TDD vs. Mockist TDD 정리**  
우아한테크코스 4기 백엔드 더즈, 티키님의 발표 내용을 기반으로, **Classic TDD와 Mockist TDD의 개념, 차이점, 장단점**을 정리하였습니다.

---

## **🔍 1. 개요**
TDD(Test-Driven Development)를 진행하면서 **테스트를 어떻게 작성할지 고민한 적이 있으신가요?**  
특히, 테스트 코드에서 **"테스트 더블(Test Double)"**을 사용할지 여부가 중요한 논점이 될 수 있습니다.

**이번 발표에서는 Classic TDD와 Mockist TDD의 차이점을 비교하고, 각 방식의 장단점을 알아봅니다.**  

### **📌 1-1. 테스트 더블이란?**
- **실제 객체를 사용하기 어려운 경우에 사용하는 가짜 객체**  
- **테스트 비용을 줄이고, 특정 상황을 시뮬레이션하기 위해 사용**  
- **대표적인 테스트 더블 종류**
  - **Dummy**: 아무런 동작을 하지 않는 객체
  - **Fake**: 실제 동작을 하지만 완전한 구현이 아님 (ex. 인메모리 DB)
  - **Stub**: 미리 정의된 값을 반환하는 객체
  - **Spy**: 호출된 내역을 기록하는 객체
  - **Mock**: 특정 동작이 일어났는지를 검증하는 객체 (이번 발표에서 중점적으로 다룸)

---

## **🔍 2. Classic TDD vs. Mockist TDD**
Classic TDD와 Mockist TDD의 차이를 이해하기 위해, **주문(Order)과 창고(Warehouse) 시스템을 예시로 살펴보겠습니다.**  
- 주문이 들어오면 **창고에서 재고를 확인**하고,  
- **재고가 충분하면 주문이 유효**해지며 창고의 재고가 감소하는 시나리오입니다.  

### **📌 2-1. Classic TDD (실제 객체 사용)**
✅ **특징**  
- **실제 객체를 사용하여 테스트를 진행**  
- 객체의 **내부 상태(state)를 검증**하는 방식 (**상태 검증**)
- 테스트가 **더 직관적이고 안정적**이지만, **협력 객체가 많아질수록 무거워짐**

✅ **Classic TDD 예제**
```java
class OrderTest {
    @Test
    void 주문이_가능하면_창고_재고가_감소한다() {
        // Given
        Product product = new Product("MacBook");
        Warehouse warehouse = new Warehouse();
        warehouse.addStock(product, 10);  // 실제 객체 사용

        Order order = new Order(product, 5);

        // When
        order.process(warehouse);

        // Then (상태 검증)
        assertEquals(5, warehouse.getStock(product));  // 재고가 줄었는지 확인
        assertTrue(order.isValid());  // 주문이 유효한지 확인
    }
}
```
✔ **장점**  
- 실제 객체를 사용하므로 **테스트가 직관적**이고, **객체 간의 협력을 자연스럽게 검증**할 수 있음.  
- **상태 기반 검증(State Verification)**을 사용하여, 내부 구현에 덜 의존적임.  

✔ **단점**  
- 테스트에서 **실제 객체를 사용하므로 의존성이 강함**.  
- 테스트 데이터가 많아질수록 **설정이 복잡해지고 실행 속도가 느려질 가능성**이 있음.  

---

### **📌 2-2. Mockist TDD (Mock 객체 사용)**
✅ **특징**  
- **Mock 객체를 사용하여 협력 객체의 동작을 시뮬레이션**  
- **객체 간의 상호작용을 검증**하는 방식 (**행위 검증**)  
- 테스트가 **더 빠르고 독립적**이지만, **구현 방식에 의존적**일 수 있음.

✅ **Mockist TDD 예제**
```java
import static org.mockito.Mockito.*;

class OrderTest {
    @Test
    void 주문이_가능하면_창고에서_재고가_감소해야_한다() {
        // Given
        Product product = new Product("MacBook");
        Warehouse warehouse = mock(Warehouse.class);  // Mock 객체 생성
        Order order = new Order(product, 5);

        when(warehouse.hasStock(product, 5)).thenReturn(true);  // 재고 확인 동작 설정

        // When
        order.process(warehouse);

        // Then (행위 검증)
        verify(warehouse).removeStock(product, 5);  // 창고에서 재고가 줄었는지 검증
        verify(warehouse).hasStock(product, 5);  // 재고 확인이 호출되었는지 검증
    }
}
```
✔ **장점**  
- **테스트 실행 속도가 빠름** (실제 객체를 생성하지 않음)  
- **단위 테스트가 독립적으로 실행 가능**  
- **데이터베이스나 네트워크 API 같은 외부 의존성 없이 테스트 가능**  

✔ **단점**  
- **구현에 의존적**이므로, 내부 로직이 바뀌면 테스트도 함께 수정해야 함.  
- **Mock 설정이 많아질 경우, 테스트가 복잡해질 수 있음.**  

---

## **🔍 3. Classic TDD vs. Mockist TDD 차이점 정리**
| **비교 항목** | **Classic TDD** | **Mockist TDD** |
|------------|-------------|-------------|
| **검증 방식** | 상태 검증 (State Verification) | 행위 검증 (Behavior Verification) |
| **테스트 대상** | 실제 객체 사용 | Mock 객체 사용 |
| **테스트 속도** | 비교적 느림 (객체 생성 및 데이터 설정 필요) | 빠름 (Mock 객체 사용) |
| **독립성** | 협력 객체가 함께 동작 | 협력 객체를 Mock으로 대체 |
| **유지보수성** | 내부 구현 변경 시 테스트 영향 적음 | 내부 구현 변경 시 Mock 설정도 변경해야 함 |
| **테스트 안정성** | 비교적 안정적 | Mock 설정이 많아지면 유지보수가 어려워질 수 있음 |

---

## **🔍 4. Inside-Out vs. Outside-In 개발 방식**
TDD 방식에 따라 **개발 진행 방식**도 달라집니다.  

### **📌 4-1. Inside-Out (Classicist)**
- 도메인(내부 로직)부터 개발을 진행하고, 점차 외부(컨트롤러)로 확장해 나가는 방식.  
- **초보자가 적용하기 쉬우며, 코드 구조를 자연스럽게 설계할 수 있음**.  
- 하지만 **객체 간 협력이 어색해질 가능성이 있음**.

✅ **Inside-Out 개발 예제**  
1️⃣ **상품(Product) 개발**  
2️⃣ **창고(Warehouse) 개발** (상품을 관리)  
3️⃣ **주문(Order) 개발** (창고와 상호작용)  
4️⃣ **컨트롤러 개발** (사용자의 요청 처리)

---

### **📌 4-2. Outside-In (Mockist)**
- UI나 컨트롤러 같은 **외부부터 개발을 진행하고, 내부 도메인을 설계하는 방식**.  
- 객체 간의 협력을 명확하게 정의할 수 있지만, **설계에 대한 깊은 이해가 필요함**.  
- **Mock 객체를 적극적으로 활용하여, 상호작용을 먼저 정의**한 후 내부 구현을 진행.

✅ **Outside-In 개발 예제**  
1️⃣ **컨트롤러(Controller) 개발**  
2️⃣ **주문(Order) 개발** (Mock을 사용하여 창고와 협력)  
3️⃣ **창고(Warehouse) 개발**  
4️⃣ **상품(Product) 개발**  

---

## **🚀 결론**
1️⃣ **Classicist(Inside-Out) TDD**: 실제 객체를 사용하여 상태 검증을 수행, 내부에서부터 개발 진행.  
2️⃣ **Mockist(Outside-In) TDD**: Mock을 사용하여 행위 검증을 수행, 외부에서부터 개발 진행.  
3️⃣ **각 방식에는 장단점이 있으므로, 특정 상황에 따라 적절한 방식을 선택하는 것이 중요하다.**  

💡 **결론적으로, 한 가지 방법만 고집할 필요는 없습니다.**  
**각 상황에 맞춰 Classicist와 Mockist TDD를 적절히 활용하는 것이 중요합니다!** 🚀



---
---


<br>
<br>


[3월 우아한테크세미나] 우아한ATDD
출처 : https://www.youtube.com/watch?v=ITVpmjM4mUE


### **📌 지속 가능한 인수 테스트 주도 개발 (ATDD) 정리**  
우아한테크코스 류성현님의 발표 내용을 기반으로, **지속 가능한 인수 테스트 주도 개발(ATDD)의 개념, 접근법, 개선 과정 및 경험**을 정리하였습니다.

---

## **🔍 1. 개요**
이 발표는 **ATDD(인수 테스트 주도 개발)를 지속 가능하게 만들기 위한 접근법과 개선 과정**을 다룹니다.  
**기술적인 내용보다는 ATDD를 어떻게 적용하고, 지속 가능하게 운영할 것인가에 대한 고민과 해결책이 중심**입니다.

### **📌 1-1. 발표의 주요 질문**
1. ATDD를 지속 가능하게 만들려면 무엇이 가장 중요할까?  
2. 개발 문화를 도입할 때 필요한 요소는 무엇일까?  
3. ATDD를 적용하는 과정에서 팀이 어떤 고민을 했고, 어떻게 개선해 나갔을까?

이 발표는 **ATDD를 단순한 개발 기법이 아닌 "팀 문화"로 자리 잡게 하는 과정**을 설명하며,  
점진적인 개선을 통해 팀에 맞게 적용한 경험을 공유합니다.

---

## **🔍 2. 인수 테스트(AT)와 인수 테스트 주도 개발(ATDD)**
### **📌 2-1. 인수 테스트(AT)란?**
- 시스템이 **인수 기준을 만족하는지 검증하는 테스트**  
- **기능 단위의 검증을 수행**하며, 주로 **API 테스트나 UI 테스트로 구현**  
- 예) 사용자가 로그인 요청을 보냈을 때, 정상적으로 인증이 되는지 확인

✅ **인수 테스트 예제 (Spring Boot + RestAssured)**
```java
@Test
void 사용자가_로그인하면_토큰을_반환한다() {
    given()
        .contentType(MediaType.JSON)
        .body(new LoginRequest("user@example.com", "password"))
    .when()
        .post("/api/login")
    .then()
        .statusCode(200)
        .body("token", notNullValue());  // 토큰이 정상적으로 반환되는지 확인
}
```

---

### **📌 2-2. 인수 테스트 주도 개발(ATDD)란?**
- 인수 테스트를 먼저 작성하고, 이를 통과하는 기능을 구현하는 개발 방법론  
- 단순한 기능 구현이 아니라, **사용자 스토리와 인수 조건을 정의하는 과정이 포함됨**  
- 개발자뿐만 아니라 **기획자, QA, 테스터와 협력하여 개발을 진행**  

✅ **ATDD 흐름**
1️⃣ **사용자 스토리(User Story) 작성**  
2️⃣ **인수 조건(AC, Acceptance Criteria) 정의**  
3️⃣ **인수 테스트(AT) 작성**  
4️⃣ **기능 구현**  
5️⃣ **TDD(Unit Test) 진행**  
6️⃣ **테스트 통과 후 리팩터링**  

✔ **즉, ATDD는 인수 테스트 작성부터 개발을 시작하여, 요구사항과 기능 구현이 자연스럽게 연결되는 방식**입니다.

---

## **🔍 3. ATDD를 지속 가능하게 만들기 위한 접근법**
**ATDD를 팀 문화로 정착시키기 위해 중요한 요소는 무엇일까요?**  
다음 세 가지 요소가 핵심이었습니다.

1️⃣ **공감대 형성 (Why? 왜 ATDD가 필요한가?)**  
   - ATDD의 필요성을 팀원들이 납득하지 못하면 지속하기 어려움.  
   - "왜 ATDD를 해야 하는가?"에 대한 공감이 필요.

2️⃣ **점진적인 적용 (완벽한 도입보다, 필요한 부분부터 적용하기)**  
   - 처음부터 모든 원칙을 적용하는 것이 아니라, **기본적인 규칙부터 시작**  
   - 이후 **팀의 상황에 맞게 점진적으로 개선**  

3️⃣ **팀 내 피드백과 개선 (실제 문제 발생 시 해결책 도출하기)**  
   - 문제가 발생할 때마다 즉시 개선  
   - 해결책을 논의하고, 단계별로 적용  

---

## **🔍 4. ATDD 적용 및 개선 과정**
팀에서는 처음부터 완벽한 ATDD를 적용한 것이 아니라,  
**필요한 부분부터 하나씩 적용하면서 점진적으로 발전**해 나갔습니다.

### **📌 4-1. ATDD 초기 도입**
1. **기본 원칙:**  
   - 인수 테스트를 먼저 작성한 후 기능을 구현  
   - **API 레벨에서 인수 테스트를 작성**하여 블랙박스 테스트로 유지  
   - 픽스처(Fixture) 활용하여 데이터 설정  

2. **문제 발생:**  
   - 테스트 간 **격리가 되지 않아 서로 영향을 주는 문제** 발생  
   - 코드가 복잡해지고 유지보수 어려워짐  
   - 신규 팀원들이 ATDD의 필요성을 이해하지 못함  

---

### **📌 4-2. 인수 테스트 개선 (격리 문제 해결)**
✅ **문제점**  
- 인수 테스트 간의 **의존성이 강해져서 특정 테스트가 깨지면 다른 테스트도 깨짐**  
- **공유 픽스처(Fixture)를 사용하면서 격리되지 않음**  

✅ **해결 방법**  
1. **픽스처 분리** → 테스트 데이터 독립성 강화  
2. **테스트 클래스와 메서드 네이밍 컨벤션 정리** → 가독성 향상  
3. **테스트 가이드 문서화** → 신규 팀원이 쉽게 이해할 수 있도록 가이드 제공  

---

### **📌 4-3. 인수 테스트 작성 개선 (Cucumber 도입)**
✅ **문제점**  
- 신규 팀원들이 ATDD의 필요성을 이해하지 못하고, 인수 테스트를 작성하지 않음.  
- **테스트 코드가 길어지고 관리가 어려워짐.**  

✅ **해결 방법: Cucumber 도입**  
- **Cucumber를 활용하여 자연어(Gherkin) 기반의 테스트 작성**  
- **시나리오 기반 테스트를 쉽게 이해하고, 재사용할 수 있도록 개선**  

✅ **Cucumber 예제**
```gherkin
Scenario: 사용자가 로그인하면 토큰을 반환한다
  Given 사용자가 이메일 "user@example.com"와 비밀번호 "password"로 로그인 요청을 보낸다
  When 로그인을 요청하면
  Then 응답 코드가 200이어야 한다
  And 토큰이 반환되어야 한다
```
```java
@When("로그인을 요청하면")
public void 로그인을_요청하면() {
    response = given()
        .contentType(MediaType.JSON)
        .body(new LoginRequest(email, password))
        .when()
        .post("/api/login");
}
```

✔ **도입 후 결과**  
- ATDD 작성이 쉬워졌고, **팀원들의 테스트 작성 참여도가 증가**  
- 테스트 코드 재사용성이 높아짐  
- 하지만, **초기 설정 및 러닝 커브(학습 곡선)이 존재하는 단점**  

---

### **📌 4-4. 인수 조건(AC) 도출 및 사용자 스토리 활용**
✅ **문제점**  
- 인수 테스트를 작성하려면 "검증할 조건(AC)"을 정의해야 하지만,  
  **어떤 기준으로 검증할지 팀원 간 합의가 부족**  

✅ **해결 방법: 사용자 스토리 + 인수 조건 도출**  
- 사용자 스토리(User Story) 작성  
- 인수 조건(AC, Acceptance Criteria) 명확히 정의  
- **팀원들이 함께 인수 조건을 정의하여 기대하는 시나리오 차이를 줄임**  

✔ **도입 후 결과**  
- 팀원들이 인수 테스트의 필요성을 공감  
- **예외 케이스와 다양한 시나리오까지 검증 가능**  

---

## **🚀 결론**
1️⃣ **ATDD는 단순한 개발 방법이 아니라, "팀 문화"이다.**  
2️⃣ **처음부터 완벽하게 적용할 필요는 없고, 점진적으로 개선해 나가는 것이 중요하다.**  
3️⃣ **팀 내 공감대 형성이 핵심이며, 필요성을 인식하지 못하면 지속 불가능하다.**  
4️⃣ **테스트의 유지보수성과 가독성을 높이는 방식(Cucumber, 인수 조건 도출 등)을 활용해야 한다.**  

💡 **즉, ATDD를 성공적으로 도입하려면 기술적 접근뿐만 아니라, "팀의 지속 가능한 개발 문화"로 정착시키는 것이 핵심입니다!** 🚀

