## 개요
- 시스템은 크게 상태 변경과 조회 기능을 제공하는데요. 주문 취소, 결제 기능은 상태 변경에 해당되며, 주문서 조회, 사용자 조회 등이 조회에 해당됩니다.
- 명령 쿼리 책임 분리 패턴(Command Query Responsibility Segregation, CQRS) 는 상태를 변경하기 위한 명령을 위한 모델과 상태를 제공하는 조회(Query)를 위한 모델을 분리하는 패턴을 의미합니다.
- 예를 들어, Order라는 리소스를 Order(명령용), OrderData(조회용) 2개의 모델로 나누어서 관리할 수 있습니다.
- 이때 OrderData를 이용해서 표현 계층에 데이터를 출력하는 데 사용하고, 애플리케이션에서는 Order를 활용해 변경을 수행할 수 있습니다.

---

<Br>


---

## CQRS 패턴의 장단점은 무엇인가요? 
- CQRS 패턴을 따르면, 소프트웨어의 유지보수성을 높일 수 있습니다. 그리고, 모델별로 성능이나 요구사항에 맞는 데이터베이스나 데이터 접근 기술을 사용할 수 있습니다.
- 예를 들어, 명령 모델은 트랜잭션이 지원되는 RDB를 사용하고, 조회 모델은 조회 성능이 높은 NoSQL을 사용할 수 있습니다.
- 단, 해당 방식은 명령 모델의 변경을 조회 모델로 전파하여 동기화시켜야 할 필요가 있을 수 있습니다.
- 또 다른 예시로, 단일 데이터베이스의 테이블에 대해 CQRS 패턴을 사용한다고 가정했을 때는 명령 모델은 도메인 모델을 구현하는데 유리한 JPA를 사용하고, 조회 모델에 대해서는 SQL 데이터 조회에 유리한 MyBatis를 사용할 수 있습니다.

- 하지만, CQRS 패턴은 구현 코드가 많고, 더 많은 구현 기술이 필요하다는 점이 단점입니다. 따라서 단일 모델을 사용할 때 발생하는 복잡함 때문에 발생하는 구현 비용과 조회 전용 모델을 만들 때 발생하는 복잡함 때문에 발생하는 구현 비용을 비교해서 신중하게 도입을 결정해야 합니다.



---
---


> ## 추가 학습자료

대규모 트랜잭션을 처리하는 배민 주문시스템 규모에 따른 진화 #우아콘2023 #우아한형제들
출처 : https://www.youtube.com/watch?v=704qQs6KoUk


<Br>

### **🚀 대규모 트랜잭션을 처리하는 배민 주문 시스템의 진화**  

---

## **📌 1. 배민 주문 시스템 소개**  

배민 주문 시스템의 백엔드는 다음과 같은 흐름을 담당합니다.  
✔ **장바구니** → **주문서 작성** → **결제 완료** → **주문 내역 조회**  

배민 주문 시스템의 독특한 특징은 **식사 시간(점심 & 저녁)에 주문량이 폭발적으로 증가**한다는 것입니다.  
✔ **평균 하루 300만 건 주문 발생**  
✔ **특정 시간대(점심·저녁)에 집중되는 트래픽**  

이처럼 **급격한 트래픽 변화**와 **대규모 데이터 처리**가 요구되는 환경에서, 시스템을 어떻게 안정적으로 운영할지 고민해야 했습니다.

---

## **📌 2. 배민 주문 시스템의 고민과 해결 과정**  

배달의 민족 주문 시스템은 크게 네 가지 고민을 해결하며 진화해 왔습니다.  
✔ **1️⃣ 단일 장애 포인트 해결 (Central DB 의존성 제거)**  
✔ **2️⃣ 대용량 데이터 성능 최적화 (CQRS 적용)**  
✔ **3️⃣ 대규모 트랜잭션 처리 (애플리케이션 샤딩 도입)**  
✔ **4️⃣ 이벤트 기반 아키텍처 개선 (내부/외부 이벤트 분리, Outbox 패턴 도입)**  

---

## **📌 3. 단일 장애 포인트 문제 해결**  

### **문제점**  
과거 배민 시스템은 **중앙 집중형 DB(루비 DB)**에 모든 시스템이 의존하고 있었습니다.  
✔ 특정 시스템이 장애가 나면 **모든 시스템이 다운**되는 현상 발생  

### **해결 방법**  
✔ **각 도메인별로 분리된 데이터 저장소 운영**  
✔ **메시지 큐(Kafka)를 활용하여 시스템 간 통신을 비동기적으로 처리**  

✔ **결과:** 한 시스템이 장애가 나도 **전체 서비스가 영향을 받지 않도록 개선**  

---

## **📌 4. 대용량 데이터 조회 성능 문제 해결**  

### **문제점**  
✔ **주문 내역 상세 조회 시 다수의 테이블 JOIN 발생 → 성능 저하**  
✔ **RDBMS 기반 조회는 점점 속도가 느려짐**  

### **해결 방법: CQRS 패턴 적용**  
✔ **주문 데이터는 RDBMS(MySQL)에 저장 (정합성 보장)**  
✔ **조회 전용 데이터는 MongoDB(NoSQL)에서 관리 (조회 속도 최적화)**  
✔ **도메인 이벤트를 활용하여 실시간 데이터 동기화**  

✔ **결과:** RDBMS는 트랜잭션 처리에 집중하고, 조회 성능은 **10배 이상 향상**  

---

## **📌 5. 대규모 트랜잭션 처리 (쓰기 부하 해결)**  

### **문제점**  
✔ **분당 주문량이 급증하면서 단일 DB의 쓰기 한계 도달**  
✔ **AWS Aurora 최상위 스펙으로도 감당 불가**  

### **해결 방법: 애플리케이션 샤딩 적용**  
✔ **데이터를 여러 DB(샤드)로 분산 저장하여 부하 분산**  
✔ **해시 기반 샤딩(Key-based Sharding) 적용 → 주문 번호 기반 샤딩 전략 사용**  

✔ **결과:** 샤드 클러스터를 활용해 **쓰기 처리 성능 3배 향상, 트랜잭션 처리 속도 안정화**  

---

## **📌 6. 이벤트 아키텍처 개선 (서비스 일관성 유지 & 유실 방지)**  

### **문제점**  
✔ **무분별한 이벤트 발행 → 서비스 로직 복잡도 증가**  
✔ **이벤트 발행이 실패하면 데이터 유실 가능성 존재**  

### **해결 방법**  
✔ **도메인 이벤트(내부)와 서비스 이벤트(외부) 분리**  
✔ **Outbox 패턴 도입 → 이벤트 발행 실패 시 재시도 가능하도록 개선**  

✔ **결과:** 서비스 로직을 **하나의 이벤트 처리기로 통합**, 이벤트 유실 방지  

---

## **📌 7. 최종 아키텍처 변화**  

이 모든 개선을 거쳐 배민 주문 시스템은 다음과 같은 구조로 발전했습니다.  
✔ **MSA 적용 → 시스템 간 느슨한 결합 유지**  
✔ **CQRS 패턴 적용 → 조회 성능 최적화**  
✔ **애플리케이션 샤딩 적용 → 쓰기 부하 해결**  
✔ **이벤트 아키텍처 개선 → 서비스 일관성 유지 & 유실 방지**  

이제 하루 **300만 건 이상의 주문을 안정적으로 처리**하는 시스템으로 성장했습니다! 🚀  

---

## **📌 8. 결론: 안정적인 대규모 트랜잭션 시스템 구축을 위한 핵심 전략**  

✔ **단일 장애 포인트 제거** → **MSA & 메시지 큐 활용**  
✔ **대용량 데이터 최적화** → **CQRS 패턴 적용**  
✔ **트랜잭션 부하 분산** → **애플리케이션 샤딩 도입**  
✔ **이벤트 기반 아키텍처 개선** → **Outbox 패턴 적용**  

📢 **"완벽한 시스템은 없습니다. 하지만 꾸준한 개선을 통해 더 나은 서비스를 만들 수 있습니다!"**  

🎤 *"긴 시간 발표 들어주셔서 감사합니다!"* 👏👏👏
