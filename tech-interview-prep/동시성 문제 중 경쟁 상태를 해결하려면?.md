`경쟁 상태(Race Condition)` 는 두 개 이상의 스레드가 공유 자원에 동시에 접근할 때 스레드 간의 실행 순서에 따라 결과가 달라지는 현상으로, 원자성과 가시성 모두 보장되어야 해결할 수 있습니다.

`원자성(Atomicity)` 은 공유 자원에 대한 작업의 단위가 더 이상 쪼갤 수 없는 하나의 연산처럼 동작하는 성질을 의미합니다.

`가시성(Visibility)` 은 한 스레드에서 변경한 값이 다른 스레드에서 즉시 확인 가능한 성질을 의미합니다.



## 원자성을 보장하지 않으면 어떤 문제가 발생하나요?
- 예를 들어 i++ 연산은 하나의 문장이지만 CPU가 이를 수행하려면 세 단계의 instruction으로 분리됩니다.

- i 변수의 기존 값을 읽음 (Read)
- 기존 값에 1을 더함 (Modify)
- 결과 값을 다시 i 변수에 할당 (Write)

연산 사이에 다른 스레드가 개입하면 기대하지 않은 결과가 발생할 수 있습니다.

![d7c8463f-9a94-4909-ab30-86e9572f8bd2](https://github.com/user-attachments/assets/dcf641b8-a9e6-4235-a744-a312c264dda3)



- 만약 두 개의 스레드가 동시에 i++ 연산을 수행할 때, Thread 1이 i + 1을 하기 전에 Thread 2가 i를 읽어서 i + 1을 수행한 후 반영하면 Thread 2의 연산은 무시됩니다.

---

## 가시성을 보장하지 않으면 어떤 문제가 발생하나요?

![93ea2c5e-cda8-464a-9703-637e255afee2](https://github.com/user-attachments/assets/2cd206a5-ffa0-4550-bb02-899d6551ce3d)

- 현대의 컴퓨터는 여러 개의 CPU 코어가 있고 각 코어마다 CPU 캐시가 존재하는데요.
- 한 스레드에서 공유 자원을 변경할 경우 메인 메모리에서 CPU 캐시로 값을 읽어들인 후, 변경된 값을 자신의 CPU 캐시에 반영합니다.
- 하지만 변경된 값이 메인 메모리에 언제 반영될지 알 수 없기 때문에 다른 스레드가 공유 자원을 읽을 때 변경 사항을 즉시 확인할 수 없습니다.


---



## java에서 원자성과 가시성을 보장하기 위해 어떤 방법을 사용할 수 있나요?
- 원자성과 가시성을 모두 보장하려면 synchronized 키워드, CAS(Compare-And-Swap) 알고리즘을 사용하는 Atomic 클래스, ReentrantLock과 같은 lock 클래스, Concurrent Collections 등을 사용해서 동기화할 수 있습니다.

- 가시성만 보장하려면 volatile 키워드로 CPU 캐시를 사용하지 않고 메인 메모리에서 공유 자원을 직접 읽거나 쓸 수 있습니다. 이 때 하나의 스레드에서만 쓰기 작업을 수행하고, 나머지 스레드는 읽기 작업만 수행해야 합니다.

<Br>

---



> ## 추가학습자료

<br>

[10분 테코톡] 알렉스, 열음의 멀티스레드와 동기화 In Java
출처 : https://www.youtube.com/watch?v=ktWcieiNzKs

<br>


---

# ✅ 발표 주제: 멀티스레드와 동기화 in Java

## 🎯 발표 목표
- 멀티스레드 환경에서 발생하는 동시성 문제를 이해하고  
- 자바에서 제공하는 동기화 기능(`synchronized`, `volatile`, `Atomic`, `CAS`)의 원리와 목적을 학습하여  
- 실무에서 적절하게 적용하고 트러블슈팅할 수 있는 능력을 키우는 것.

---

## 1. 📦 공유 자원(Shared Resource)과 임계 영역(Critical Section)

### 🧱 공유 자원
- 여러 스레드가 동시에 접근 가능한 자원 (예: 전역 변수, 리스트, 카운터 등)

### 🔒 임계 영역
- 공유 자원 중에서도 동시에 접근할 경우 **문제(데이터 손상, 비정상 결과)**가 발생할 수 있는 영역

### 🧠 비유
> 화장실처럼 한 사람만 사용할 수 있는 공간. 여러 사람이 동시에 들어오면 충돌이 납니다.

---

## 2. ⚠️ 경쟁 상태 (Race Condition)

### ✔️ 정의
- 둘 이상의 스레드가 **순차적으로 실행되어야 할 작업을 동시에 수행**하여, 실행 순서에 따라 결과가 달라지는 문제

### 🎓 대표 패턴 예제

#### 📌 1) Read - Modify - Write
```java
count = count + 1;
```
- 읽기(read) → 수정(modify) → 쓰기(write)의 세 단계
- 동시에 두 스레드가 이 연산을 하면 `count`가 꼬일 수 있음

> 비유: 동시에 두 명이 엘리베이터 호출 버튼을 눌렀지만 실제로는 한 번만 호출된 것처럼 기록됨

---

#### 📌 2) Check - Then - Act
```java
if (count < 30) {
    print("폐강 위험!");
}
```
- `if` 통과 후 출력까지 사이에 값이 변경되면 **잘못된 출력** 발생

> 비유: 카페 잔여 좌석을 확인하고 결제하려 했는데, 누군가 먼저 선점해서 결제는 실패!

---

## 3. 🧩 동기화를 위한 두 핵심: 원자성 + 가시성

### 1️⃣ 원자성 (Atomicity)

#### ✔️ 정의
- 여러 개의 작업이 **더 이상 쪼갤 수 없는 하나의 단위**처럼 실행되어야 함

#### 💡 왜 필요할까?
- Read → Modify → Write가 각각 쪼개져 있으면 중간에 다른 스레드가 끼어들 수 있음

> 비유: 은행 송금은 “출금 + 입금”이 하나의 동작. 중간에 끊기면 큰일!

---

### 2️⃣ 가시성 (Visibility)

#### ✔️ 정의
- 한 스레드의 변경 사항이 **다른 스레드에게도 즉시 보이는가?**

#### 💡 문제 원인
- 자바는 CPU 캐시를 사용하여 연산 → 메모리 최신값이 **즉시 반영되지 않음**

> 비유: 식당 영업 종료인데도, 전광판엔 “영업 중”이라 손님은 계속 들어옴

---

## 4. 🔧 자바의 동기화 도구들

---

### 📍 블로킹 방식 (Blocking Synchronization)

#### 🧰 도구: `synchronized`, `wait()`, `notify()`, `notifyAll()`

#### 작동 원리
- 자바는 **모니터(Monitor)** 기반으로 동기화
- 임계 영역에 한 번에 하나의 스레드만 접근 가능
- 나머지 스레드는 대기 (대기열에서 큐잉)

> 비유: 공중전화 부스. 한 사람만 통화 가능, 다른 사람은 줄 서 있음.

#### ✨ 장점
- 원자성, 가시성 모두 보장

#### ⚠️ 단점
- 성능 저하 (대기 시간 발생)
- **데드락 위험**

---

### 🔁 데드락(Deadlock)

#### 📌 정의
- 두 스레드가 서로의 자원을 기다리며 **영원히 종료되지 않는 상태**

> 비유: 형은 티셔츠 입고 바지 기다리고, 동생은 바지 입고 티셔츠 기다리는 상황

---

### 📍 논블로킹 방식 (Non-Blocking Synchronization)

#### 🧰 도구: `AtomicInteger`, `AtomicReference`, `AtomicBoolean` 등  
→ 내부적으로 **CAS 알고리즘** 사용

#### ⚙️ CAS (Compare-And-Swap)

1. 기대값(expect)을 설정
2. 현재 자원값이 기대값과 같으면 → 새 값으로 교체
3. 아니면 → 실패, 재시도

> 비유: 온라인 좌석 예매 중, 다른 사람이 먼저 예매했으면 내 선택은 무효 → 다시 선택

#### ✨ 장점
- 스레드 간 대기 없음 → 성능 높음
- **원자성과 가시성** 보장

---

## 5. 🧠 쓰레드 안전한 객체 설계 전략

### 🎯 핵심 원칙
1. **공유 자원을 최대한 피하자**
2. 꼭 써야 한다면, **캡슐화**해서 한 클래스에 모아 관리
3. 동기화 로직은 **명확하게 문서화**

> 비유: 냉장고에 모두가 공유하는 반찬만 넣고, 개인 음식은 각자 보관함에!

---

## 📊 핵심 개념 요약 테이블

| 개념 | 의미 | 도구 / 설명 |
|------|------|--------------|
| 공유 자원 | 여러 스레드가 접근 | 전역 변수, 리스트 등 |
| 임계 영역 | 문제 발생 가능한 코드 | synchronized 블럭 |
| 경쟁 상태 | 실행 순서에 따라 결과 달라짐 | RMW, Check-Then-Act |
| 원자성 | 연산 단위를 쪼갤 수 없음 | CAS, synchronized |
| 가시성 | 최신 값이 보장되는가 | volatile, AtomicXXX |
| 블로킹 방식 | 스레드 대기 필수 | synchronized, wait/notify |
| 논블로킹 방식 | 다른 스레드와 상관없이 동작 | AtomicInteger, CAS |
| 데드락 | 자원 대기 중 무한 멈춤 | 락 순서 정렬, timeout 사용 |

---

## 🧩 마무리 한 줄 정리

> 멀티스레드는 ‘여럿이 한 냉장고 쓰는 상황’과 같다.  
> 충돌 없이 협력하려면 **질서 있는 락과 동기화 설계**가 필요하다.  
> Java는 `synchronized`, `Atomic`, `CAS` 등을 통해 다양한 선택지를 제공하며,  
> 문제 상황에 따라 **적절한 동기화 전략을 선택하는 것**이 실력이다.

---

## 📚 개발자라로써 더 알아야 할 심화 키워드

| 키워드 | 설명 |
|--------|------|
| `volatile` | 가시성만 보장 (원자성 X) |
| `ThreadLocal` | 스레드별 독립된 변수 저장 |
| `CompletableFuture` | 비동기 프로그래밍 지원 |
| `ExecutorService` | 스레드 풀 기반 스케줄링 |
| `ForkJoinPool` | 분할 정복 기반 병렬 처리 |
| `ReentrantLock` | 명시적 락, 공정성 설정 가능 |
| `ReadWriteLock` | 읽기 다중, 쓰기 단일 락 구현 가능 |

---
