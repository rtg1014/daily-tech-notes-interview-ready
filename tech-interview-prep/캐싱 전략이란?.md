# 캐시는 성능 향상과 부하 감소를 목표로 합니다. 
이때 캐시를 사용하는 양상이 서비스에 큰 영향을 끼치기도 합니다.

---

<br>

## Cache Aside(Lazy Loading) 방식이란?
- Cache Aside 방식은 캐시 히트 시 캐시에서 데이터를 불러오며, 캐시 미스 발생 시 원본 데이터베이스에서 조회하여 반환합니다.
- 애플리케이션은 캐시 미스가 발생하면 해당 데이터를 캐시에 적재합니다.

해당 방식은 실제 요청된 데이터만 캐시에 저장되므로 불필요한 데이터 캐싱을 줄일 수 있습니다. 
또한, 캐시에 문제가 발생해도 애플리케이션은 원본 데이터베이스 직접 접근할 수 있기 때문에 서비스가 계속 작동할 수 있다는 장점이 있습니다. 
하지만, 캐시 미스가 발생하는 경우에만 데이터를 캐시에 적재하기 때문에 원본 데이터베이스와 같은 데이터가 아닐 수도 있으며, 초기에는 대량의 캐시 미스로 인한 데이터베이스 부하가 발생할 수 있습니다.

---

<br>


## 캐시 불일치(Cachge Inconsistency) 란 
- 원본 데이터베이스에 저장된 데이터와 캐시에 저장된 데이터가 서로 다른 상황을 의미합니다.
- Write Through, Cache Invalidation, Write Behind 방식으로 이러한 캐시 불일치를 해소할 수 있습니다.


---

<br>


## Write Through 방식은 원본 데이터에 대한 변경분이 생긴 경우, 매번 캐시에 해당 데이터를 찾아 함께 변경하는 방식입니다. 
- 2번 쓰기가 발생하지만, 캐시는 항상 최신 데이터를 가지고 있습니다. 캐시는 다시 조회되는 경우에 빛을 발휘합니다.
- 무작정 데이터를 갱신하거나 저장하는 방식은 리소스 낭비가 될 수 있으니 해당 방식을 사용하는 경우, 만료 시간을 사용하는 것이 권장됩니다.


---

<br>

## Cache Invalidation 방식은 원본 데이터에 대한 변경분이 생긴 경우, 캐시 데이터를 만료시키는 방식입니다. 
- Write Through 방식의 단점을 보완한 방식이며 캐시에 데이터가 삭제되니 캐시 불일치에 대한 걱정을 하지 않아도 됩니다.



---


<br>

## Write Behind(Write Back) 방식은 원본 데이터에 대한 변경분이 생긴 경우, 캐시를 먼저 업데이트한 이후 추후에 원본 데이터를 변경합니다. 
- 디스크 쓰기 작업을 비동기 작업으로 수행하여 성능을 개선할 수 있습니다.
- 원본 데이터와 캐시가 일시적으로 일치하지 않을 수 있있기 때문에 쓰기 작업이 빈번하며 일시적인 캐시 불일치를 허용하는 서비스에서 유용하게 사용될 수 있습니다.



---

<br>
<br>


---




## 추가 학습자료
[10분 테코톡] 라온의 Cache & Redis
출처링크 : https://www.youtube.com/watch?v=tVZ15cCRAyE


<br>


## 📌 **Cache & Redis 발표 요약**

---

### 🔎 **1. 캐시(Cache)란?**

- **캐시 정의**: 데이터나 값을 미리 복사해 두는 임시 저장소로, DB에 직접 접근하지 않고 빠르게 데이터를 제공해 성능을 향상시킴.
- **사용 이유**: 
  - 클라이언트 요청이 많아질수록 DB 부하가 증가함.
  - 서버와 DB 사이에 캐시를 도입하면 성능 문제를 해결할 수 있음.

---

### 💡 **2. 캐시의 활용 사례**
- **Dynamic Programming**: 이전 값을 저장해 반복 계산을 줄이는 알고리즘 패턴.
- **JPA의 영속성 컨텍스트**: 1차 캐시를 통해 DB 접근 횟수를 줄여 성능 향상.

---

### 📈 **3. 캐시를 사용하는 이유 – 데이터 지역성**
- **파레토 법칙**: 전체 데이터 중 자주 사용되는 20%를 캐싱하면 성능 향상 가능.
- **데이터 지역성**:
  - **공간적 지역성**: 한번 참조한 데이터 주변의 데이터를 참조할 확률이 높음.
  - **시간적 지역성**: 한번 참조한 데이터가 빠른 시일 내에 재사용될 가능성이 높음.

---

### 🧩 **4. 캐시 전략 패턴**
캐시를 활용할 때 사용하는 **읽기(Read)**와 **쓰기(Write)** 전략.

#### 📚 **(1) 읽기 전략**
1. **Look Aside 패턴**:  
   - 애플리케이션이 먼저 캐시를 조회하고, 없을 경우 DB에서 가져와 캐시에 저장.  
   - **장점**: 캐시 문제 발생 시 DB에서 데이터 조회 가능.  
   - **단점**: 데이터 정합성 유지 어려움.

2. **Read Through 패턴**:  
   - 모든 데이터 요청이 캐시를 거침.  
   - 캐시에 없을 경우, 캐시가 DB에서 데이터를 가져와 저장 후 반환.  
   - **장점**: 데이터 정합성 보장.  
   - **단점**: 캐시 장애 시 애플리케이션 장애 발생 가능.

---

#### ✍ **(2) 쓰기 전략**
1. **Write Around 패턴**:  
   - 캐시를 거치지 않고 DB에 직접 데이터 저장.  
   - **장점**: 캐시 리소스 절약.  
   - **단점**: 캐시와 DB 간 데이터 정합성 어려움.

2. **Write Back 패턴**:  
   - 데이터를 캐시에 먼저 저장하고 일정 시간 후 DB에 한 번에 쓰기.  
   - **장점**: DB 쓰기 횟수 줄여 성능 향상.  
   - **단점**: 캐시 장애 시 데이터 유실 위험.

3. **Write Through 패턴**:  
   - 모든 쓰기 작업이 캐시와 DB에 동시에 저장됨.  
   - **장점**: 데이터 정합성 보장.  
   - **단점**: 두 번의 쓰기 작업으로 성능 저하 가능.

---

### ⚠ **5. 캐시 사용 시 주의사항**
- **자주 사용되며 변경되지 않는 데이터**를 캐싱.
- **유실되어도 문제없는 데이터**를 캐싱.
- **데이터 정합성 유지**를 항상 고려.

---

### 🔐 **6. Redis란?**
- **Redis**: Remote Dictionary Server의 약자로, **Key-Value 기반 NoSQL DB**.
- **HashMap**과 유사하며, 메모리에 데이터를 저장해 빠른 접근 가능.

---

### 📊 **7. Redis의 특징**
1. **빠른 성능**: 메모리에 저장되므로 Get/Set 명령어 속도가 빠름(10만 TPS).  
2. **다양한 자료구조 지원**: String, Hash, List, Set, Sorted Set 등.  
3. **Single Thread**: 한 번에 하나의 명령만 처리, Race Condition 발생 확률 낮음.  
4. **영속화(Persistence) 기능**:
   - **RDB**: 특정 간격으로 메모리 데이터를 압축해 저장(빠른 복구 가능).  
   - **AOF**: 데이터 변경 시마다 명령어를 기록(실시간 백업 가능).

---

### 💡 **8. Redis를 우아하게 사용하는 방법**
1. **데이터 타입에 맞는 자료구조 사용**:  
   - 예: 사용자 최근 검색 목록은 Sorted Set으로 관리하면 중복 제거 및 정렬 용이.

2. **O(N) 명령어 사용 주의**:  
   - `KEYS`, `FLUSHALL` 등의 명령어는 실행 시간이 길어 성능 저하 발생.

3. **메모리 관리 필수**:  
   - Redis는 인메모리 DB로 **메모리 단편화**가 발생할 수 있음.  
   - **RSS 값**을 모니터링해 메모리 관리 필요.

4. **Redis의 목적성 설정**:  
   - **캐시용**으로 사용할 경우, 데이터 유실이 발생해도 큰 문제가 없는 데이터를 사용.  
   - 영속화 기능을 꼭 사용할 필요는 없음.

---

### ✅ **9. 정리**
- 어떤 데이터를 캐싱할지, 어떤 패턴으로 캐시를 구성할지, 어떤 시스템을 선택할지 고민해 프로젝트에 적용.
- Redis는 캐시뿐만 아니라 다양한 용도로 활용 가능하지만, 서비스 목적에 맞게 설정하고 관리해야 함.

---





